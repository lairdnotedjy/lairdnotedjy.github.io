<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="baidu-site-verification" content="codeva-6wmKWl5hmx" />
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2426182848439341"
     crossorigin="anonymous"></script>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-33RJLY0818"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-33RJLY0818');
</script>

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.sovdating.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Hello dev">
<meta property="og:type" content="website">
<meta property="og:title" content="Sovdating Linux">
<meta property="og:url" content="https://www.sovdating.com/page/49/index.html">
<meta property="og:site_name" content="Sovdating Linux">
<meta property="og:description" content="Hello dev">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="DJY">
<meta property="article:tag" content="golang python linux ubuntu centos rust">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://www.sovdating.com/page/49/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/49/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Sovdating Linux - some code for program</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Sovdating Linux</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">some code for program</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">DJY</p>
  <div class="site-description" itemprop="description">Hello dev</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">548</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">93</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">381</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.sovdating.com/Python3-beginner-s-handbook-three/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DJY">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sovdating Linux">
      <meta itemprop="description" content="Hello dev">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sovdating Linux">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/Python3-beginner-s-handbook-three/" class="post-title-link" itemprop="url">Python3入门手册之三</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2015-07-06 20:50:25" itemprop="dateCreated datePublished" datetime="2015-07-06T20:50:25+08:00">2015-07-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-01-24 10:24:42" itemprop="dateModified" datetime="2024-01-24T10:24:42+08:00">2024-01-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming-Notes/" itemprop="url" rel="index"><span itemprop="name">Programming Notes</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><em>Version：Python 3.4.3 (v3.4.3:9b73f1c3e601, Feb 24 2015, 22:44:40) [MSC v.1600 64 bit (AMD64)] on win32</em></p>
<h3 id="文件与I-O"><a href="#文件与I-O" class="headerlink" title="文件与I&#x2F;O"></a>文件与I&#x2F;O</h3><h4 id="读写文本数据"><a href="#读写文本数据" class="headerlink" title="读写文本数据"></a>读写文本数据</h4><p>使用带有<code>rt</code>模式的<code>open()</code>函数读取文本文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.csv&#x27;</span>, mode=<span class="string">&#x27;rt&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.read()</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.csv&#x27;</span>, mode=<span class="string">&#x27;rt&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        <span class="built_in">print</span>(line, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>类似的，为了写入一个文本文件，使用带有<code>wt</code>模式的<code>open()</code>函数，如果之前文件内容存在则清除并覆盖掉</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;dest.csv&#x27;</span>, mode=<span class="string">&#x27;wt&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&#x27;text1&#x27;</span>)  <span class="comment"># 注意该方式写入文件默认没有换行符，需手动添加</span></span><br><span class="line">    f.write(<span class="string">&#x27;text2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;dest.csv&#x27;</span>, mode=<span class="string">&#x27;wt&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;text1&#x27;</span>, file=f)  <span class="comment"># 该方式写入文件默认换行，无需手动添加</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;text2&#x27;</span>, file=f)</span><br></pre></td></tr></table></figure>
<p>如果是在已存在文件中添加内容，使用模式为<code>at</code>的<code>open()</code>函数。<code>with</code>控制块结束时，文件会自动关闭。你也可以不使用<code>with</code>语句，但是这时候你就必须记得手动关闭文件。</p>
<p><strong>使用print输出元组</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">row = (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(*row, sep=<span class="string">&#x27;,&#x27;</span>, end=<span class="string">&#x27;。&#x27;</span>) <span class="comment"># Prints a,b,c。</span></span><br></pre></td></tr></table></figure>
<h4 id="读写字节数据"><a href="#读写字节数据" class="headerlink" title="读写字节数据"></a>读写字节数据</h4><p>使用模式为<code>rb</code>或<code>wb</code>的<code>open()</code>函数来读取或写入二进制数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;dest2.csv&#x27;</span>, mode=<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">b&#x27;HelloWorld!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;dest2.csv&#x27;</span>, mode=<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(f.read())</span><br></pre></td></tr></table></figure>
<p>在读取二进制数据的时候，字节字符串和文本字符串的语义差异可能会导致一个潜在的陷阱。特别需要注意的是，索引和迭代动作返回的是字节的值而不是字节字符串。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Text string</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">0</span>]</span><br><span class="line"><span class="string">&#x27;H&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> c <span class="keyword">in</span> t:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(c)</span><br><span class="line">...</span><br><span class="line">H</span><br><span class="line">e</span><br><span class="line">l</span><br><span class="line">l</span><br><span class="line">o</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Byte string</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">b&#x27;Hello World&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">0</span>]</span><br><span class="line"><span class="number">72</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> c <span class="keyword">in</span> b:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(c)</span><br><span class="line">...</span><br><span class="line"><span class="number">72</span></span><br><span class="line"><span class="number">101</span></span><br><span class="line"><span class="number">108</span></span><br><span class="line"><span class="number">108</span></span><br><span class="line"><span class="number">111</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="向不存在的文件中写入数据"><a href="#向不存在的文件中写入数据" class="headerlink" title="向不存在的文件中写入数据"></a>向不存在的文件中写入数据</h4><p>如果只允许向不存在的文件写入数据，可以在<code>open()</code>函数中使用<code>x</code>模式来代替<code>w</code>模式来解决这个问题。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;dest2.csv&#x27;</span>, mode=<span class="string">&#x27;xt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;E:/workspaces/Python3/edu/shu/python/study/FileAndIO.py&quot;</span>, line <span class="number">33</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;dest2.csv&#x27;</span>, mode=<span class="string">&#x27;xt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">FileExistsError: [Errno <span class="number">17</span>] File exists: <span class="string">&#x27;dest2.csv&#x27;</span></span><br></pre></td></tr></table></figure>
<p>由提示信息可知，当该文件在系统中已经存在的时候，是不允许继续向其中写入内容的。如果文件是二进制的，使用<code>xb</code>来代替<code>xt</code>。</p>
<h4 id="字符串的I-O操作"><a href="#字符串的I-O操作" class="headerlink" title="字符串的I&#x2F;O操作"></a>字符串的I&#x2F;O操作</h4><p>使用<code>io.StringIO()</code>和<code>io.BytesIO()</code>类来创建类文件对象操作字符串数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line">s = io.StringIO()</span><br><span class="line">s.write(<span class="string">&#x27;Hello World!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\nthis is a test&#x27;</span>, file=s)</span><br><span class="line"><span class="comment"># 向控制台输出内容</span></span><br><span class="line"><span class="built_in">print</span>(s.getvalue())</span><br><span class="line"></span><br><span class="line">s = io.StringIO(<span class="string">&#x27;Hello World!\n&#x27;</span>)</span><br><span class="line"><span class="comment"># 先读取4个字符</span></span><br><span class="line"><span class="built_in">print</span>(s.read(<span class="number">4</span>))</span><br><span class="line"><span class="comment"># 读取剩下的字符</span></span><br><span class="line"><span class="built_in">print</span>(s.read())</span><br></pre></td></tr></table></figure>
<p><code>io.StringIO</code>只能用于文本。如果你要操作二进制数据，要使用<code>io.BytesIO</code>类来代替</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = io.BytesIO()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.write(<span class="string">b&#x27;binary data&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.getvalue()</span><br><span class="line"><span class="string">b&#x27;binary data&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="读写压缩文件"><a href="#读写压缩文件" class="headerlink" title="读写压缩文件"></a>读写压缩文件</h4><p><code>gzip</code>和<code>bz2</code>模块可以很容易的处理这些文件。两个模块都为<code>open()</code>函数提供了另外的实现来解决这个问题</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gzip compression</span></span><br><span class="line"><span class="keyword">import</span> gzip</span><br><span class="line"><span class="keyword">with</span> gzip.<span class="built_in">open</span>(<span class="string">&#x27;somefile.gz&#x27;</span>, <span class="string">&#x27;rt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    text = f.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># bz2 compression</span></span><br><span class="line"><span class="keyword">import</span> bz2</span><br><span class="line"><span class="keyword">with</span> bz2.<span class="built_in">open</span>(<span class="string">&#x27;somefile.bz2&#x27;</span>, <span class="string">&#x27;rt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    text = f.read()</span><br></pre></td></tr></table></figure>
<p>类似的，为了写入压缩数据，可以这样做</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gzip compression</span></span><br><span class="line"><span class="keyword">import</span> gzip</span><br><span class="line"><span class="keyword">with</span> gzip.<span class="built_in">open</span>(<span class="string">&#x27;somefile.gz&#x27;</span>, <span class="string">&#x27;wt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># bz2 compression</span></span><br><span class="line"><span class="keyword">import</span> bz2</span><br><span class="line"><span class="keyword">with</span> bz2.<span class="built_in">open</span>(<span class="string">&#x27;somefile.bz2&#x27;</span>, <span class="string">&#x27;wt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(text)</span><br></pre></td></tr></table></figure>
<p>大部分情况下读写压缩数据都是很简单的。但是要注意的是选择一个正确的文件模式是非常重要的。如果你不指定模式，那么默认的就是二进制模式，如果这时候程序想要接受的是文本数据，那么就会出错。<br>当写入压缩数据时，可以使用<code>compresslevel</code>这个可选的关键字参数来指定一个压缩级别。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> gzip.<span class="built_in">open</span>(<span class="string">&#x27;somefile.gz&#x27;</span>, <span class="string">&#x27;wt&#x27;</span>, compresslevel=<span class="number">5</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(text)</span><br></pre></td></tr></table></figure>
<p>默认的等级是<code>9</code>，也是最高的压缩等级。等级越低性能越好，但是数据压缩程度也越低。</p>
<p>最后一点，<code>gzip.open()</code>和<code>bz2.open()</code>还有一个很少被知道的特性，它们可以作用在一个已存在并以二进制模式打开的文件上。比如，下面代码是可行的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gzip</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;somefile.gz&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line"><span class="keyword">with</span> gzip.<span class="built_in">open</span>(f, <span class="string">&#x27;rt&#x27;</span>) <span class="keyword">as</span> g:</span><br><span class="line">    text = g.read()</span><br></pre></td></tr></table></figure>
<p>这样就允许<code>gzip</code>和<code>bz2</code>模块可以工作在许多类文件对象上，比如套接字，管道和内存中文件等。</p>
<h4 id="读取二进制数据到可变缓冲区中"><a href="#读取二进制数据到可变缓冲区中" class="headerlink" title="读取二进制数据到可变缓冲区中"></a>读取二进制数据到可变缓冲区中</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_into_buffer</span>(<span class="params">filename</span>):</span><br><span class="line">    buf = <span class="built_in">bytearray</span>(os.path.getsize(filename))</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.readinto(buf)</span><br><span class="line">    <span class="keyword">return</span> buf</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Write a sample file</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;sample.bin&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="meta">... </span>    f.write(<span class="string">b&#x27;Hello World&#x27;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>buf = read_into_buffer(<span class="string">&#x27;sample.bin&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>buf</span><br><span class="line"><span class="built_in">bytearray</span>(<span class="string">b&#x27;Hello World&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>buf[<span class="number">0</span>:<span class="number">5</span>] = <span class="string">b&#x27;Hallo&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>buf</span><br><span class="line"><span class="built_in">bytearray</span>(<span class="string">b&#x27;Hallo World&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;newsample.bin&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="meta">... </span>    f.write(buf)</span><br><span class="line">...</span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure>
<p>文件对象的<code>readinto()</code>方法能被用来为预先分配内存的数组填充数据，甚至包括由<code>array</code>模块或<code>numpy</code>库创建的数组。和普通<code>read()</code>方法不同的是，<code>readinto()</code>填充已存在的缓冲区而不是为新对象重新分配内存再返回它们。因此，你可以使用它来避免大量的内存分配操作。比如，如果你读取一个由相同大小的记录组成的二进制文件时，你可以像下面这样写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">record_size = <span class="number">32</span> <span class="comment"># Size of each record (adjust value)</span></span><br><span class="line"></span><br><span class="line">buf = <span class="built_in">bytearray</span>(record_size)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;somefile&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n = f.readinto(buf)</span><br><span class="line">        <span class="keyword">if</span> n &lt; record_size:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># Use the contents of buf</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<h4 id="文件路径名的操作"><a href="#文件路径名的操作" class="headerlink" title="文件路径名的操作"></a>文件路径名的操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>path = <span class="string">&#x27;/Users/beazley/Data/data.csv&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Get the last component of the path</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.basename(path)</span><br><span class="line"><span class="string">&#x27;data.csv&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Get the directory name</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.dirname(path)</span><br><span class="line"><span class="string">&#x27;/Users/beazley/Data&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Join path components together</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.join(<span class="string">&#x27;tmp&#x27;</span>, <span class="string">&#x27;data&#x27;</span>, os.path.basename(path))</span><br><span class="line"><span class="string">&#x27;tmp/data/data.csv&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Expand the user&#x27;s home directory</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>path = <span class="string">&#x27;~/Data/data.csv&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.expanduser(path)</span><br><span class="line"><span class="string">&#x27;/Users/beazley/Data/data.csv&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Split the file extension</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.splitext(path)</span><br><span class="line">(<span class="string">&#x27;~/Data/data&#x27;</span>, <span class="string">&#x27;.csv&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>对于任何的文件名的操作，你都应该使用<code>os.path</code>模块，而不是使用标准字符串操作来构造自己的代码。特别是为了可移植性考虑的时候更应如此，因为<code>os.path</code>模块知道<code>Unix</code>和<code>Windows</code>系统之间的差异并且能够可靠地处理类似<code>Data/data.csv</code>和<code>Data\data.csv</code>这样的文件名。其次，你真的不应该浪费时间去重复造轮子。通常最好是直接使用已经为你准备好的功能。</p>
<p>使用如下方式测试文件的类型，如果测试的文件不存在的时候，结果都会返回<strong>False</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Is a regular file</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.isfile(<span class="string">&#x27;/etc/passwd&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Is a directory</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.isdir(<span class="string">&#x27;/etc/passwd&#x27;</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Is a symbolic link</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.islink(<span class="string">&#x27;/usr/local/bin/python3&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Get the file linked to</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.realpath(<span class="string">&#x27;/usr/local/bin/python3&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;/usr/local/bin/python3.3&#x27;</span></span><br></pre></td></tr></table></figure>
<p>如果你还想获取元数据(比如文件大小或者是修改日期)，也可以使用<code>os.path</code>模块来解决</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.getsize(<span class="string">&#x27;/etc/passwd&#x27;</span>)</span><br><span class="line"><span class="number">3669</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.getmtime(<span class="string">&#x27;/etc/passwd&#x27;</span>)</span><br><span class="line"><span class="number">1272478234.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> time</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>time.ctime(os.path.getmtime(<span class="string">&#x27;/etc/passwd&#x27;</span>))</span><br><span class="line"><span class="string">&#x27;Wed Apr 28 13:10:34 2010&#x27;</span></span><br></pre></td></tr></table></figure>
<p>使用<code>os.listdir()</code>函数来获取某个目录中的文件列表</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">names = os.listdir(<span class="string">&#x27;somedir&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>获取目录中的列表是很容易的，但是其返回结果只是目录中实体名列表而已。如果你还想获取其他的元信息，比如文件大小，修改时间等等，你或许还需要使用到<code>os.path</code>模块中的函数或者<code>os.stat()</code>函数来收集数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example of getting a directory listing</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line">pyfiles = glob.glob(<span class="string">&#x27;*.py&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get file sizes and modification dates</span></span><br><span class="line">name_sz_date = [(name, os.path.getsize(name), os.path.getmtime(name))</span><br><span class="line">                <span class="keyword">for</span> name <span class="keyword">in</span> pyfiles]</span><br><span class="line"><span class="keyword">for</span> name, size, mtime <span class="keyword">in</span> name_sz_date:</span><br><span class="line">    <span class="built_in">print</span>(name, size, mtime)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Alternative: Get file metadata</span></span><br><span class="line">file_metadata = [(name, os.stat(name)) <span class="keyword">for</span> name <span class="keyword">in</span> pyfiles]</span><br><span class="line"><span class="keyword">for</span> name, meta <span class="keyword">in</span> file_metadata:</span><br><span class="line">    <span class="built_in">print</span>(name, meta.st_size, meta.st_mtime)</span><br></pre></td></tr></table></figure>
<h4 id="增加或改变已打开文件的编码"><a href="#增加或改变已打开文件的编码" class="headerlink" title="增加或改变已打开文件的编码"></a>增加或改变已打开文件的编码</h4><p>如果你想给一个以二进制模式打开的文件添加<code>Unicode</code>编码&#x2F;解码方式，可以使用<code>io.TextIOWrapper()</code>对象包装它。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line">u = urllib.request.urlopen(<span class="string">&#x27;http://www.python.org&#x27;</span>)</span><br><span class="line">f = io.TextIOWrapper(u, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">text = f.read()</span><br></pre></td></tr></table></figure>
<p>如果你想修改一个已经打开的文本模式的文件的编码方式，可以先使用<code>detach()</code>方法移除掉已存在的文本编码层，并使用新的编码方式代替。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.stdout.encoding</span><br><span class="line"><span class="string">&#x27;UTF-8&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.stdout = io.TextIOWrapper(sys.stdout.detach(), encoding=<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.stdout.encoding</span><br><span class="line"><span class="string">&#x27;latin-1</span></span><br></pre></td></tr></table></figure>
<p>在文本模式打开的文件中写入原始的字节数据，将字节数据直接写入文件的缓冲区即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.stdout.write(<span class="string">b&#x27;Hello\n&#x27;</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: must be <span class="built_in">str</span>, <span class="keyword">not</span> <span class="built_in">bytes</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.stdout.buffer.write(<span class="string">b&#x27;Hello\n&#x27;</span>)</span><br><span class="line">Hello</span><br><span class="line"><span class="number">5</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>类似的，能够通过读取文本文件的<code>buffer</code>属性来读取二进制数据。</p>
<h4 id="创建临时文件和文件夹"><a href="#创建临时文件和文件夹" class="headerlink" title="创建临时文件和文件夹"></a>创建临时文件和文件夹</h4><p><code>tempfile</code>模块中有很多的函数可以完成这任务。为了创建一个匿名的临时文件，可以使用<code>tempfile.TemporaryFile</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tempfile <span class="keyword">import</span> TemporaryFile</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> TemporaryFile(<span class="string">&#x27;w+t&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># Read/write to the file</span></span><br><span class="line">    f.write(<span class="string">&#x27;Hello World\n&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;Testing\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Seek back to beginning and read the data</span></span><br><span class="line">    f.seek(<span class="number">0</span>)</span><br><span class="line">    data = f.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Temporary file is destroyed</span></span><br></pre></td></tr></table></figure>
<p><code>TemporaryFile()</code>的第一个参数是文件模式，通常来讲文本模式使用<code>w+t</code>，二进制模式使用<code>w+b</code>。这个模式同时支持读和写操作，在这里是很有用的，因为当你关闭文件去改变模式的时候，文件实际上已经不存在了。<code>TemporaryFile()</code>另外还支持跟内置的<code>open()</code>函数一样的参数。</p>
<p>在大多数<code>Unix</code>系统上，通过<code>TemporaryFile()</code>创建的文件都是匿名的，甚至连目录都没有。如果你想打破这个限制，可以使用<code>NamedTemporaryFile()</code>来代替。比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tempfile <span class="keyword">import</span> NamedTemporaryFile</span><br><span class="line"><span class="keyword">with</span> NamedTemporaryFile(<span class="string">&#x27;w+t&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;filename is:&#x27;</span>, f.name)</span><br><span class="line">    ...</span><br><span class="line"><span class="comment"># File automatically destroyed</span></span><br></pre></td></tr></table></figure>
<p>这里，被打开文件的<code>f.name</code>属性包含了该临时文件的文件名。当你需要将文件名传递给其他代码来打开这个文件的时候，这个就很有用了。和<code>TemporaryFile()</code>一样，结果文件关闭时会被自动删除掉。如果你不想这么做，可以传递一个关键字参数<code>delte=False</code>即可。比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> NamedTemporaryFile(<span class="string">&#x27;w+t&#x27;</span>, delete=<span class="literal">False</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;filename is:&#x27;</span>, f.name)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>为了创建一个临时目录，可以使用<code>tempfile.TemporaryDirectory()</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tempfile <span class="keyword">import</span> TemporaryDirectory</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> TemporaryDirectory() <span class="keyword">as</span> dirname:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;dirname is:&#x27;</span>, dirname)</span><br><span class="line">    <span class="comment"># Use the directory</span></span><br><span class="line">    ...</span><br><span class="line"><span class="comment"># Directory and all contents destroyed</span></span><br></pre></td></tr></table></figure>
<p><code>TemporaryFile()</code>、<code>NamedTemporaryFile()</code>和<code>TemporaryDirectory()</code>函数应该是处理临时文件目录的最简单的方式了，因为它们会自动处理所有的创建和清理步骤。在一个更低的级别，你可以使用<code>mkstemp()</code>和<code>mkdtemp()</code>来创建临时文件和目录。</p>
<h4 id="与串行端口的数据通信"><a href="#与串行端口的数据通信" class="headerlink" title="与串行端口的数据通信"></a>与串行端口的数据通信</h4><p>尽管你可以通过使用Python内置的I&#x2F;O模块来完成这个任务，但对于串行通信最好的选择是使用<a target="_blank" rel="noopener" href="http://pyserial.sourceforge.net/">pySerial</a>包。这个包的使用非常简单，先安装<code>pySerial</code>，使用类似下面这样的代码就能很容易的打开一个串行端口：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> serial</span><br><span class="line">ser = serial.Serial(<span class="string">&#x27;/dev/tty.usbmodem641&#x27;</span>, <span class="comment"># Device name varies</span></span><br><span class="line">                    baudrate=<span class="number">9600</span>,</span><br><span class="line">                    bytesize=<span class="number">8</span>,</span><br><span class="line">                    parity=<span class="string">&#x27;N&#x27;</span>,</span><br><span class="line">                    stopbits=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>设备名对于不同的设备和操作系统是不一样的。比如，在<code>Windows</code>系统上，你可以使用0，1等表示的一个设备来打开通信端口<code>COM0</code>和<code>COM1</code>。一旦端口打开，那就可以使用<code>read()</code>，<code>readline()</code>和<code>write()</code>函数读写数据了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ser.write(<span class="string">b&#x27;G1 X50 Y50\r\n&#x27;</span>)</span><br><span class="line">resp = ser.readline()</span><br></pre></td></tr></table></figure>
<h4 id="序列化Python对象"><a href="#序列化Python对象" class="headerlink" title="序列化Python对象"></a>序列化Python对象</h4><p>对于序列化最普遍的做法就是使用<code>pickle</code>模块。为了将一个对象保存到一个文件中，可以这样做：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line">data = ... <span class="comment"># Some Python object</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;somefile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">pickle.dump(data, f)</span><br></pre></td></tr></table></figure>
<p>为了将一个对象转储为一个字符串，可以使用<code>pickle.dumps()</code>：<br><code>s = pickle.dumps(data)</code><br>为了从字节流中恢复一个对象，使用<code>picle.load()</code>或<code>pickle.loads()</code>函数。比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Restore from a file</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;somefile&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">data = pickle.load(f)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Restore from a string</span></span><br><span class="line">data = pickle.loads(s)</span><br></pre></td></tr></table></figure>
<h3 id="数据编码和处理"><a href="#数据编码和处理" class="headerlink" title="数据编码和处理"></a>数据编码和处理</h3><h4 id="读写CSV数据"><a href="#读写CSV数据" class="headerlink" title="读写CSV数据"></a>读写CSV数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="comment"># 将CSV中的数据读入元组中，并允许使用列名如row.Symbol和row.Change（Symbol和Change是CSV文件中的列名）</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;stock.csv&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f_csv = csv.reader(f)</span><br><span class="line">    headings = <span class="built_in">next</span>(f_csv)</span><br><span class="line">    Row = namedtuple(<span class="string">&#x27;Row&#x27;</span>, headings)</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> f_csv:</span><br><span class="line">        row = Row(*r)</span><br><span class="line">        <span class="comment"># Process row</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<p>另外一个选择就是将数据读取到一个字典序列中去。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;stocks.csv&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f_csv = csv.DictReader(f)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> f_csv:</span><br><span class="line">        <span class="comment"># process row</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<p>在这个版本中，你可以使用列名去访问每一行的数据了。比如，<code>row[&#39;Symbol&#39;]</code>或者<code>row[&#39;Change&#39;]</code>。</p>
<p>为了写入<code>CSV</code>数据，你仍然可以使用<code>CSV</code>模块，不过这时候先创建一个<code>writer</code>对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">headers = [<span class="string">&#x27;Symbol&#x27;</span>,<span class="string">&#x27;Price&#x27;</span>,<span class="string">&#x27;Date&#x27;</span>,<span class="string">&#x27;Time&#x27;</span>,<span class="string">&#x27;Change&#x27;</span>,<span class="string">&#x27;Volume&#x27;</span>]</span><br><span class="line">rows = [(<span class="string">&#x27;AA&#x27;</span>, <span class="number">39.48</span>, <span class="string">&#x27;6/11/2007&#x27;</span>, <span class="string">&#x27;9:36am&#x27;</span>, -<span class="number">0.18</span>, <span class="number">181800</span>),</span><br><span class="line">         (<span class="string">&#x27;AIG&#x27;</span>, <span class="number">71.38</span>, <span class="string">&#x27;6/11/2007&#x27;</span>, <span class="string">&#x27;9:36am&#x27;</span>, -<span class="number">0.15</span>, <span class="number">195500</span>),</span><br><span class="line">         (<span class="string">&#x27;AXP&#x27;</span>, <span class="number">62.58</span>, <span class="string">&#x27;6/11/2007&#x27;</span>, <span class="string">&#x27;9:36am&#x27;</span>, -<span class="number">0.46</span>, <span class="number">935000</span>),</span><br><span class="line">       ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;stocks.csv&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f_csv = csv.writer(f)</span><br><span class="line">    f_csv.writerow(headers)</span><br><span class="line">    f_csv.writerows(rows)</span><br></pre></td></tr></table></figure>
<p>如果你有一个字典序列的数据，可以像这样做</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">headers = [<span class="string">&#x27;Symbol&#x27;</span>, <span class="string">&#x27;Price&#x27;</span>, <span class="string">&#x27;Date&#x27;</span>, <span class="string">&#x27;Time&#x27;</span>, <span class="string">&#x27;Change&#x27;</span>, <span class="string">&#x27;Volume&#x27;</span>]</span><br><span class="line">rows = [&#123;<span class="string">&#x27;Symbol&#x27;</span>:<span class="string">&#x27;AA&#x27;</span>, <span class="string">&#x27;Price&#x27;</span>:<span class="number">39.48</span>, <span class="string">&#x27;Date&#x27;</span>:<span class="string">&#x27;6/11/2007&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Time&#x27;</span>:<span class="string">&#x27;9:36am&#x27;</span>, <span class="string">&#x27;Change&#x27;</span>:-<span class="number">0.18</span>, <span class="string">&#x27;Volume&#x27;</span>:<span class="number">181800</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;Symbol&#x27;</span>:<span class="string">&#x27;AIG&#x27;</span>, <span class="string">&#x27;Price&#x27;</span>: <span class="number">71.38</span>, <span class="string">&#x27;Date&#x27;</span>:<span class="string">&#x27;6/11/2007&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Time&#x27;</span>:<span class="string">&#x27;9:36am&#x27;</span>, <span class="string">&#x27;Change&#x27;</span>:-<span class="number">0.15</span>, <span class="string">&#x27;Volume&#x27;</span>: <span class="number">195500</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;Symbol&#x27;</span>:<span class="string">&#x27;AXP&#x27;</span>, <span class="string">&#x27;Price&#x27;</span>: <span class="number">62.58</span>, <span class="string">&#x27;Date&#x27;</span>:<span class="string">&#x27;6/11/2007&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Time&#x27;</span>:<span class="string">&#x27;9:36am&#x27;</span>, <span class="string">&#x27;Change&#x27;</span>:-<span class="number">0.46</span>, <span class="string">&#x27;Volume&#x27;</span>: <span class="number">935000</span>&#125;,</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;stocks.csv&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f_csv = csv.DictWriter(f, headers)</span><br><span class="line">    f_csv.writeheader()</span><br><span class="line">    f_csv.writerows(rows)</span><br></pre></td></tr></table></figure>
<h4 id="读写JSON数据"><a href="#读写JSON数据" class="headerlink" title="读写JSON数据"></a>读写JSON数据</h4><p><code>json</code>模块提供了一种很简单的方式来编码和解码JSON数据。其中两个主要的函数是<code>json.dumps()</code>和<code>json.loads()</code>，要比其他序列化函数库如<code>pickle</code>的接口少得多。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;ACME&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;shares&#x27;</span> : <span class="number">100</span>,</span><br><span class="line">    <span class="string">&#x27;price&#x27;</span> : <span class="number">542.23</span></span><br><span class="line">&#125;</span><br><span class="line">json_str = json.dumps(data)</span><br></pre></td></tr></table></figure>
<p>将JSON编码的字符串转回一个Python数据结构<br><code>data = json.loads(json_str)</code><br>如果你要处理的是文件而不是字符串，你可以使用<code>json.dump()</code>和<code>json.load()</code>来编码和解码JSON数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Writing JSON data</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    json.dump(data, f)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Reading data back</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.json&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = json.load(f)</span><br></pre></td></tr></table></figure>
<h4 id="解析简单的XML数据"><a href="#解析简单的XML数据" class="headerlink" title="解析简单的XML数据"></a>解析简单的XML数据</h4><p>可以使用<code>xml.etree.ElementTree</code>模块从简单的XML文档中提取数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">from</span> xml.etree.ElementTree <span class="keyword">import</span> parse</span><br><span class="line"></span><br><span class="line"><span class="comment"># Download the RSS feed and parse it</span></span><br><span class="line">u = urlopen(<span class="string">&#x27;http://planet.python.org/rss20.xml&#x27;</span>)</span><br><span class="line">doc = parse(u)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Extract and output tags of interest</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> doc.iterfind(<span class="string">&#x27;channel/item&#x27;</span>):</span><br><span class="line">    title = item.findtext(<span class="string">&#x27;title&#x27;</span>)</span><br><span class="line">    date = item.findtext(<span class="string">&#x27;pubDate&#x27;</span>)</span><br><span class="line">    link = item.findtext(<span class="string">&#x27;link&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(title)</span><br><span class="line">    <span class="built_in">print</span>(date)</span><br><span class="line">    <span class="built_in">print</span>(link)</span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>
<p><code>xml.etree.ElementTree.parse()</code>函数解析整个XML文档并将其转换成一个文档对象。然后，你就能使用<code>find()</code>、<code>iterfind()</code>和<code>findtext()</code>等方法来搜索特定的XML元素了。这些函数的参数就是某个指定的标签名，例如<code>channel/item</code>或<code>title</code>。</p>
<p><code>ElementTree</code>模块中的每个元素有一些重要的属性和方法，在解析的时候非常有用。<code>tag</code>属性包含了标签的名字，<code>text</code>属性包含了内部的文本，而<code>get()</code>方法能获取属性值。</p>
<p>有一点要强调的是<code>xml.etree.ElementTree</code>并不是<code>XML</code>解析的唯一方法。对于更高级的应用程序，你需要考虑使用<code>lxml</code>。它使用了和<code>ElementTree</code>同样的编程接口，因此上面的例子同样也适用于<code>lxml</code>。你只需要将刚开始的<code>import</code>语句换成<code>from lxml.etree import parse</code>就行了。<code>lxml</code>完全遵循<code>XML</code>标准，并且速度也非常快，同时还支持验证，<code>XSLT</code>和<code>XPath</code>等特性。</p>
<h4 id="增量式解析大型XML文件"><a href="#增量式解析大型XML文件" class="headerlink" title="增量式解析大型XML文件"></a>增量式解析大型XML文件</h4><p>任何时候只要你遇到增量式的数据处理时，第一时间就应该想到迭代器和生成器。 下面是一个很简单的函数，只使用很少的内存就能增量式的处理一个大型XML文件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xml.etree.ElementTree <span class="keyword">import</span> iterparse</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_and_remove</span>(<span class="params">filename, path</span>):</span><br><span class="line">    path_parts = path.split(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    doc = iterparse(filename, (<span class="string">&#x27;start&#x27;</span>, <span class="string">&#x27;end&#x27;</span>))</span><br><span class="line">    <span class="comment"># Skip the root element</span></span><br><span class="line">    <span class="built_in">next</span>(doc)</span><br><span class="line"></span><br><span class="line">    tag_stack = []</span><br><span class="line">    elem_stack = []</span><br><span class="line">    <span class="keyword">for</span> event, elem <span class="keyword">in</span> doc:</span><br><span class="line">        <span class="keyword">if</span> event == <span class="string">&#x27;start&#x27;</span>:</span><br><span class="line">            tag_stack.append(elem.tag)</span><br><span class="line">            elem_stack.append(/)</span><br><span class="line">        <span class="keyword">elif</span> event == <span class="string">&#x27;end&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> tag_stack == path_parts:</span><br><span class="line">                <span class="keyword">yield</span> elem</span><br><span class="line">                elem_stack[-<span class="number">2</span>].remove(elem)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                tag_stack.pop()</span><br><span class="line">                elem_stack.pop()</span><br><span class="line">            <span class="keyword">except</span> IndexError:</span><br><span class="line">                <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p><code>iterparse()</code>方法允许对<code>XML</code>文档进行增量操作。使用时，你需要提供文件名和一个包含下面一种或多种类型的事件列表：<code>start</code>,<code>end</code>,<code>start-ns</code>和<code>end-ns</code>。由<code>iterparse()</code>创建的迭代器会产生形如(event, elem)的元组，其中<code>event</code>是上述事件列表中的某一个，而<code>elem</code>是相应的XML元素。</p>
<p><code>start</code>事件在某个元素第一次被创建并且还没有被插入其他数据(如子元素)时被创建。而<code>end</code>事件在某个元素已经完成时被创建。尽管没有在例子中演示，<code>start-ns</code>和<code>end-ns</code>事件被用来处理<code>XML</code>文档命名空间的声明。</p>
<h4 id="将字典转换为XML"><a href="#将字典转换为XML" class="headerlink" title="将字典转换为XML"></a>将字典转换为XML</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xml.etree.ElementTree <span class="keyword">import</span> Element</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dict_to_xml</span>(<span class="params">tag, d</span>):</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Turn a simple dict of key/value pairs into XML</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">elem = Element(tag)</span><br><span class="line"><span class="keyword">for</span> key, val <span class="keyword">in</span> d.items():</span><br><span class="line">    child = Element(key)</span><br><span class="line">    child.text = <span class="built_in">str</span>(val)</span><br><span class="line">    elem.append(child)</span><br><span class="line"><span class="keyword">return</span> elem</span><br></pre></td></tr></table></figure>
<p>对于<code>I/O</code>操作，使用<code>xml.etree.ElementTree</code>中的<code>tostring()</code>函数很容易就能将它转换成一个字节字符串。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> xml.etree.ElementTree <span class="keyword">import</span> tostring</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tostring(e)</span><br><span class="line"><span class="string">b&#x27;&lt;stock&gt;&lt;price&gt;490.1&lt;/price&gt;&lt;shares&gt;100&lt;/shares&gt;&lt;name&gt;GOOG&lt;/name&gt;&lt;/stock&gt;&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p><code>xml.sax.saxutils</code>中的<code>escape()</code>和<code>unescape()</code>函数提供对HTML实体的转换方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> xml.sax.saxutils <span class="keyword">import</span> escape, unescape</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>escape(<span class="string">&#x27;&lt;spam&gt;&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;&lt;spam&gt;&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>unescape(_)</span><br><span class="line"><span class="string">&#x27;&lt;spam&gt;&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="解析和修改XML"><a href="#解析和修改XML" class="headerlink" title="解析和修改XML"></a>解析和修改XML</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> xml.etree.ElementTree <span class="keyword">import</span> parse, Element</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>doc = parse(<span class="string">&#x27;pred.xml&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>root = doc.getroot()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>root</span><br><span class="line">&lt;Element <span class="string">&#x27;stop&#x27;</span> at <span class="number">0x100770cb0</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Remove a few elements</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>root.remove(root.find(<span class="string">&#x27;sri&#x27;</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>root.remove(root.find(<span class="string">&#x27;cr&#x27;</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Insert a new element after &lt;nm&gt;...&lt;/nm&gt;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>root.getchildren().index(root.find(<span class="string">&#x27;nm&#x27;</span>))</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = Element(<span class="string">&#x27;spam&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.text = <span class="string">&#x27;This is a test&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>root.insert(<span class="number">2</span>, e)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Write back to a file</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>doc.write(<span class="string">&#x27;newpred.xml&#x27;</span>, xml_declaration=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h4 id="编码和解码十六进制数"><a href="#编码和解码十六进制数" class="headerlink" title="编码和解码十六进制数"></a>编码和解码十六进制数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Initial byte string</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">b&#x27;hello&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Encode as hex</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> binascii</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h = binascii.b2a_hex(s)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h</span><br><span class="line"><span class="string">b&#x27;68656c6c6f&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Decode back to bytes</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>binascii.a2b_hex(h)</span><br><span class="line"><span class="string">b&#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure>
<p>类似的功能同样可以在<code>base64</code>模块中找到</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> base64</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h = base64.b16encode(s)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h</span><br><span class="line"><span class="string">b&#x27;68656C6C6F&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>base64.b16decode(h)</span><br><span class="line"><span class="string">b&#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure>
<p>大部分情况下，通过使用上述的函数来转换十六进制是很简单的。上面两种技术的主要不同在于大小写的处理。函数<code>base64.b16decode()</code>和<code>base64.b16encode()</code>只能操作大写形式的十六进制字母，而<code>binascii</code>模块中的函数大小写都能处理。<br>还有一点需要注意的是编码函数所产生的输出总是一个字节字符串。如果想强制以<code>Unicode</code>形式输出，你需要增加一个额外的界面步骤。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>h = base64.b16encode(s)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(h)</span><br><span class="line"><span class="string">b&#x27;68656C6C6F&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(h.decode(<span class="string">&#x27;ascii&#x27;</span>))</span><br><span class="line">68656C6C6F</span><br></pre></td></tr></table></figure>
<p>在解码十六进制数时，函数<code>b16decode()</code>和<code>a2b_hex()</code>可以接受字节或<code>unicode</code>字符串。但是，<code>unicode</code>字符串必须仅仅只包含<code>ASCII</code>编码的十六进制数。</p>
<h4 id="编码解码Base64数据"><a href="#编码解码Base64数据" class="headerlink" title="编码解码Base64数据"></a>编码解码Base64数据</h4><p><code>base64</code>模块中有两个函数<code>b64encode()</code>and<code>b64decode()</code>可以帮你解决这个问题。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Some byte data</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">b&#x27;hello&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Encode as Base64</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = base64.b64encode(s)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="string">b&#x27;aGVsbG8=&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Decode from Base64</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>base64.b64decode(a)</span><br><span class="line"><span class="string">b&#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="读写二进制数组数据"><a href="#读写二进制数组数据" class="headerlink" title="读写二进制数组数据"></a>读写二进制数组数据</h4><p>可以使用<code>struct</code>模块处理二进制数据。下面是一段示例代码将一个Python元组列表写入一个二进制文件，并使用<code>struct</code>将每个元组编码为一个结构体。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> Struct</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_records</span>(<span class="params">records, <span class="built_in">format</span>, f</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Write a sequence of tuples to a binary file of structures.</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    record_struct = Struct(<span class="built_in">format</span>)</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> records:</span><br><span class="line">        f.write(record_struct.pack(*r))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    records = [ (<span class="number">1</span>, <span class="number">2.3</span>, <span class="number">4.5</span>),</span><br><span class="line">                (<span class="number">6</span>, <span class="number">7.8</span>, <span class="number">9.0</span>),</span><br><span class="line">                (<span class="number">12</span>, <span class="number">13.4</span>, <span class="number">56.7</span>) ]</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.b&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        write_records(records, <span class="string">&#x27;&lt;idd&#x27;</span>, f)</span><br></pre></td></tr></table></figure>
<p>如果你打算以块的形式增量读取文件，你可以这样做：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> Struct</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_records</span>(<span class="params"><span class="built_in">format</span>, f</span>):</span><br><span class="line">    record_struct = Struct(<span class="built_in">format</span>)</span><br><span class="line">    chunks = <span class="built_in">iter</span>(<span class="keyword">lambda</span>: f.read(record_struct.size), <span class="string">b&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> (record_struct.unpack(chunk) <span class="keyword">for</span> chunk <span class="keyword">in</span> chunks)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.b&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> rec <span class="keyword">in</span> read_records(<span class="string">&#x27;&lt;idd&#x27;</span>, f):</span><br><span class="line">            <span class="comment"># Process rec</span></span><br><span class="line">            ...</span><br></pre></td></tr></table></figure>
<p>如果你想将整个文件一次性读取到一个字节字符串中，然后在分片解析。那么你可以这样做：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> Struct</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">unpack_records</span>(<span class="params"><span class="built_in">format</span>, data</span>):</span><br><span class="line">    record_struct = Struct(<span class="built_in">format</span>)</span><br><span class="line">    <span class="keyword">return</span> (record_struct.unpack_from(data, offset)</span><br><span class="line">            <span class="keyword">for</span> offset <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(data), record_struct.size))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.b&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        data = f.read()</span><br><span class="line">    <span class="keyword">for</span> rec <span class="keyword">in</span> unpack_records(<span class="string">&#x27;&lt;idd&#x27;</span>, data):</span><br><span class="line">        <span class="comment"># Process rec</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<p><strong>参考文献</strong><br>[1] <a target="_blank" rel="noopener" href="https://www.gitbook.com/book/lenkimo/byte-of-python-chinese-edition/details">A Byte of Python3</a><br>[2] <a target="_blank" rel="noopener" href="http://python3-cookbook.readthedocs.org/zh_CN/latest/c01/p08_calculating_with_dict.html">python3-cookbook</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.sovdating.com/Python3-beginner-s-handbook-two/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DJY">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sovdating Linux">
      <meta itemprop="description" content="Hello dev">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sovdating Linux">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/Python3-beginner-s-handbook-two/" class="post-title-link" itemprop="url">Python3入门手册之二</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2015-07-04 21:16:41" itemprop="dateCreated datePublished" datetime="2015-07-04T21:16:41+08:00">2015-07-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-01-24 10:24:42" itemprop="dateModified" datetime="2024-01-24T10:24:42+08:00">2024-01-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming-Notes/" itemprop="url" rel="index"><span itemprop="name">Programming Notes</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><em>Version：Python 3.4.3 (v3.4.3:9b73f1c3e601, Feb 24 2015, 22:44:40) [MSC v.1600 64 bit (AMD64)] on win32</em></p>
<h3 id="数字日期和时间"><a href="#数字日期和时间" class="headerlink" title="数字日期和时间"></a>数字日期和时间</h3><h4 id="数字的四舍五入"><a href="#数字的四舍五入" class="headerlink" title="数字的四舍五入"></a>数字的四舍五入</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding: UTF-8</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Created on 2015/7/3  23:01</span></span><br><span class="line"><span class="string">@author: &#x27;WX&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">round</span>(<span class="number">1.23</span>, <span class="number">1</span>))  <span class="comment"># Prints 1.2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">round</span>(<span class="number">1.27</span>, <span class="number">1</span>))  <span class="comment"># Prints 1.3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">round</span>(-<span class="number">1.27</span>, <span class="number">1</span>))  <span class="comment"># Prints -1.3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">round</span>(<span class="number">1.25361</span>, <span class="number">3</span>))  <span class="comment"># Prints 1.254</span></span><br><span class="line"><span class="comment"># 当一个值刚好在两个边界的中间的时候，round 函数返回离它最近的偶数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">round</span>(<span class="number">1.25</span>, <span class="number">1</span>))  <span class="comment"># Prints 1.2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">round</span>(<span class="number">1.35</span>, <span class="number">1</span>))  <span class="comment"># Prints 1.4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 传给 round() 函数的 ndigits 参数可以是负数，这种情况下， 舍入运算会作用在十位、百位、千位等上面</span></span><br><span class="line">a = <span class="number">1627731</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">round</span>(a, -<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">round</span>(a, -<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">round</span>(a, -<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化浮点数，保留指定的小数点后保留位数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">format</span>(<span class="number">1.23456</span>, <span class="string">&#x27;0.2f&#x27;</span>))</span><br></pre></td></tr></table></figure>
<h4 id="执行精确的浮点数运算"><a href="#执行精确的浮点数运算" class="headerlink" title="执行精确的浮点数运算"></a>执行精确的浮点数运算</h4><p>如果需要精确的浮点数计算，那么推荐使用<code>decimal</code>模块的<code>Decimal</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line"></span><br><span class="line">a = Decimal(<span class="string">&#x27;1.3&#x27;</span>)</span><br><span class="line">b = Decimal(<span class="string">&#x27;1.7&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a / b)</span><br><span class="line"></span><br><span class="line">a = Decimal(<span class="string">&#x27;4.2&#x27;</span>)</span><br><span class="line">b = Decimal(<span class="string">&#x27;2.1&#x27;</span>)</span><br><span class="line">c = a.__add__(b)</span><br><span class="line">d = a + b</span><br><span class="line"><span class="built_in">print</span>(c)  <span class="comment"># Prints 6.3</span></span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># Prints 6.3</span></span><br></pre></td></tr></table></figure>
<h4 id="无穷大与NaN"><a href="#无穷大与NaN" class="headerlink" title="无穷大与NaN"></a>无穷大与NaN</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">b = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">c = <span class="built_in">float</span>(<span class="string">&#x27;nan&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># Prints inf</span></span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment"># Prints -inf</span></span><br><span class="line"><span class="built_in">print</span>(c)  <span class="comment"># Prints nan</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="comment"># 可以使用如下方式测试这些值的存在，测试一个NaN值的唯一安全的方法就是使用math.isnan()</span></span><br><span class="line"><span class="built_in">print</span>(math.isinf(a))  <span class="comment"># Prints True</span></span><br><span class="line"><span class="built_in">print</span>(math.isnan(c))  <span class="comment"># Prints True</span></span><br></pre></td></tr></table></figure>
<h4 id="分数运算"><a href="#分数运算" class="headerlink" title="分数运算"></a>分数运算</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># fractions模块可以被用来执行包含分数的数学运算</span></span><br><span class="line"><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction</span><br><span class="line"></span><br><span class="line">a = Fraction(<span class="number">5</span>, <span class="number">4</span>)</span><br><span class="line">b = Fraction(<span class="number">7</span>, <span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(a + b)  <span class="comment"># Prints 27/16</span></span><br><span class="line">c = a * b</span><br><span class="line"><span class="built_in">print</span>(c)  <span class="comment"># Prints 35/64</span></span><br><span class="line"><span class="built_in">print</span>(c.numerator)  <span class="comment"># 获取分子</span></span><br><span class="line"><span class="built_in">print</span>(c.denominator)  <span class="comment"># 获取分母</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">float</span>(c))  <span class="comment"># 强转成float类型</span></span><br><span class="line">d = <span class="number">3.75</span></span><br><span class="line">e = Fraction(*d.as_integer_ratio())  <span class="comment"># 强转float类型到分数类型</span></span><br><span class="line"><span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure>
<h4 id="大型数组运算"><a href="#大型数组运算" class="headerlink" title="大型数组运算"></a>大型数组运算</h4><p>涉及到数组的重量级运算操作，可以使用<code>NumPy</code>库。<code>NumPy</code>的一个主要特征是它会给Python提供一个数组对象，相比标准的Python列表而言更适合用来做数学运算</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Python lists</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x * <span class="number">2</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x + <span class="number">10</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: can only concatenate <span class="built_in">list</span> (<span class="keyword">not</span> <span class="string">&quot;int&quot;</span>) to <span class="built_in">list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x + y</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Numpy arrays</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ay = np.array([<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax * <span class="number">2</span></span><br><span class="line">array([<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax + <span class="number">10</span></span><br><span class="line">array([<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax + ay</span><br><span class="line">array([ <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax * ay</span><br><span class="line">array([ <span class="number">5</span>, <span class="number">12</span>, <span class="number">21</span>, <span class="number">32</span>])</span><br></pre></td></tr></table></figure>
<p><code>NumPy</code>还为数组操作提供了大量的通用函数，这些函数可以作为<code>math</code>模块中类似函数的替代</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.sqrt(ax)</span><br><span class="line">array([ <span class="number">1.</span> , <span class="number">1.41421356</span>, <span class="number">1.73205081</span>, <span class="number">2.</span> ])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.cos(ax)</span><br><span class="line">array([ <span class="number">0.54030231</span>, -<span class="number">0.41614684</span>, -<span class="number">0.9899925</span> , -<span class="number">0.65364362</span>])</span><br></pre></td></tr></table></figure>
<p>使用<code>NumPy</code>构造一个二维数组的例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>grid = np.zeros(shape=(<span class="number">10000</span>,<span class="number">10000</span>), dtype=<span class="built_in">float</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>grid</span><br><span class="line">    array([[ <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, ..., <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">    [ <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, ..., <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">    [ <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, ..., <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">    ...,</span><br><span class="line">    [ <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, ..., <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">    [ <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, ..., <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">    [ <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, ..., <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>]])</span><br></pre></td></tr></table></figure>
<p>对于<code>NumPy</code>构造的数组，如何选择行和列呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">[ <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">[ <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Select row 1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>]</span><br><span class="line">array([<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Select column 1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[:,<span class="number">1</span>]</span><br><span class="line">array([ <span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Select a subregion and change it</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>:<span class="number">3</span>, <span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">array([[ <span class="number">6</span>, <span class="number">7</span>],</span><br><span class="line">        [<span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>:<span class="number">3</span>, <span class="number">1</span>:<span class="number">3</span>] += <span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">        [ <span class="number">5</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">8</span>],</span><br><span class="line">        [ <span class="number">9</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Broadcast a row vector across an operation on all rows</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a + [<span class="number">100</span>, <span class="number">101</span>, <span class="number">102</span>, <span class="number">103</span>]</span><br><span class="line">array([[<span class="number">101</span>, <span class="number">103</span>, <span class="number">105</span>, <span class="number">107</span>],</span><br><span class="line">        [<span class="number">105</span>, <span class="number">117</span>, <span class="number">119</span>, <span class="number">111</span>],</span><br><span class="line">        [<span class="number">109</span>, <span class="number">121</span>, <span class="number">123</span>, <span class="number">115</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">        [ <span class="number">5</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">8</span>],</span><br><span class="line">        [ <span class="number">9</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Conditional assignment on an array</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.where(a &lt; <span class="number">10</span>, a, <span class="number">10</span>)</span><br><span class="line">array([[ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">        [ <span class="number">5</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">8</span>],</span><br><span class="line">        [ <span class="number">9</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>]])</span><br></pre></td></tr></table></figure>
<p>通常我们导入<code>NumPy</code>模块的时候会使用语句<code>import numpy as np</code>。这样的话你就不用再你的程序里面一遍遍的敲入<code>numpy</code>，只需要输入<code>np</code>就行了，节省了不少时间。</p>
<h4 id="基本的日期与时间转换"><a href="#基本的日期与时间转换" class="headerlink" title="基本的日期与时间转换"></a>基本的日期与时间转换</h4><p>为了执行不同时间单位的转换和计算，请使用<code>datetime</code>模块</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = timedelta(days=<span class="number">2</span>, hours=<span class="number">6</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = timedelta(hours=<span class="number">4.5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = a + b</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.days</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.seconds</span><br><span class="line"><span class="number">37800</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.seconds / <span class="number">3600</span></span><br><span class="line"><span class="number">10.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.total_seconds() / <span class="number">3600</span></span><br><span class="line"><span class="number">58.5</span></span><br></pre></td></tr></table></figure>
<p>如果你想表示指定的日期和时间，先创建一个<code>datetime</code>实例然后使用标准的数学运算来操作它们</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = datetime(<span class="number">2012</span>, <span class="number">9</span>, <span class="number">23</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(a + timedelta(days=<span class="number">10</span>))</span><br><span class="line"><span class="number">2012</span>-<span class="number">10</span>-03 <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = datetime(<span class="number">2012</span>, <span class="number">12</span>, <span class="number">21</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = b - a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.days</span><br><span class="line"><span class="number">89</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now = datetime.today()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(now)</span><br><span class="line"><span class="number">2012</span>-<span class="number">12</span>-<span class="number">21</span> <span class="number">14</span>:<span class="number">54</span>:<span class="number">43.094063</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(now + timedelta(minutes=<span class="number">10</span>))</span><br><span class="line"><span class="number">2012</span>-<span class="number">12</span>-<span class="number">21</span> <span class="number">15</span>:04:<span class="number">43.094063</span></span><br></pre></td></tr></table></figure>
<p>对大多数基本的日期和时间处理问题，<code>datetime</code>模块以及足够了。 如果你需要执行更加复杂的日期操作，比如处理时区，模糊时间范围，节假日计算等等， 可以考虑使用<code>dateutil</code>模块</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = datetime(<span class="number">2012</span>, <span class="number">9</span>, <span class="number">23</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a + timedelta(months=<span class="number">1</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">&#x27;months&#x27;</span> <span class="keyword">is</span> an invalid keyword argument <span class="keyword">for</span> this function</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> dateutil.relativedelta <span class="keyword">import</span> relativedelta</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a + relativedelta(months=+<span class="number">1</span>)</span><br><span class="line">datetime.datetime(<span class="number">2012</span>, <span class="number">10</span>, <span class="number">23</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a + relativedelta(months=+<span class="number">4</span>)</span><br><span class="line">datetime.datetime(<span class="number">2013</span>, <span class="number">1</span>, <span class="number">23</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Time between two dates</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = datetime(<span class="number">2012</span>, <span class="number">12</span>, <span class="number">21</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = b - a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">datetime.timedelta(<span class="number">89</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = relativedelta(b, a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">relativedelta(months=+<span class="number">2</span>, days=+<span class="number">28</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.months</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.days</span><br><span class="line"><span class="number">28</span></span><br></pre></td></tr></table></figure>
<h4 id="字符串转换为日期"><a href="#字符串转换为日期" class="headerlink" title="字符串转换为日期"></a>字符串转换为日期</h4><p>使用Python的标准模块<code>datetime</code>可以很容易的解决这个问题</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">text = <span class="string">&#x27;2012-09-20&#x27;</span></span><br><span class="line">y = datetime.strptime(text, <span class="string">&#x27;%Y-%m-%d&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(y)  <span class="comment"># Prints 2012-09-20 00:00:00</span></span><br><span class="line">z = datetime.now()</span><br><span class="line"><span class="built_in">print</span>(z)  <span class="comment"># Prints 2015-07-04 15:49:17.419612</span></span><br><span class="line">diff = z - y</span><br><span class="line"><span class="built_in">print</span>(diff)  <span class="comment"># Prints 1017 days, 15:49:17.419612</span></span><br></pre></td></tr></table></figure>
<p><code>datetime.strptime()</code>方法支持很多的格式化代码，比如<code>%Y</code>代表4位数年份，<code>%m</code>代表两位数月份。还有一点值得注意的是这些格式化占位符也可以反过来使用，将日期输出为指定的格式字符串形式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>z</span><br><span class="line">datetime.datetime(<span class="number">2012</span>, <span class="number">9</span>, <span class="number">23</span>, <span class="number">21</span>, <span class="number">37</span>, <span class="number">4</span>, <span class="number">177393</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nice_z = datetime.strftime(z, <span class="string">&#x27;%A %B %d, %Y&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nice_z</span><br><span class="line"><span class="string">&#x27;Sunday September 23, 2012&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="结合时区的日期操作"><a href="#结合时区的日期操作" class="headerlink" title="结合时区的日期操作"></a>结合时区的日期操作</h4><p>对几乎所有涉及到时区的问题，你都应该使用<code>pytz</code>模块。这个包提供了<code>Olson</code>时区数据库，它是时区信息的事实上的标准，在很多语言和操作系统里面都可以找到。<code>pytz</code>模块一个主要用途是将<code>datetime</code>库创建的简单日期对象本地化。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> pytz <span class="keyword">import</span> timezone</span><br><span class="line"></span><br><span class="line">d = datetime(<span class="number">2015</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">30</span>, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># Prints 2015-01-01 09:30:00</span></span><br><span class="line"><span class="comment"># central = timezone(&#x27;Asia/Shanghai&#x27;)</span></span><br><span class="line"><span class="comment"># Localize the date for Chicago</span></span><br><span class="line">central = timezone(<span class="string">&#x27;US/Central&#x27;</span>)</span><br><span class="line">loc_d = central.localize(d)</span><br><span class="line"><span class="built_in">print</span>(loc_d)  <span class="comment"># Prints 2015-01-01 09:30:00-06:00</span></span><br></pre></td></tr></table></figure>
<p>一旦日期被本地化了， 它就可以转换为其他时区的时间了。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bang_d = loc_d.astimezone(timezone(<span class="string">&#x27;Asia/Shanghai&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(bang_d)  <span class="comment"># Prints 2015-01-01 23:30:00+08:00</span></span><br></pre></td></tr></table></figure>
<p>当涉及到时区操作的时候，有个问题就是我们如何得到时区的名称。比如，在这个例子中，我们如何知道<code>“Asia/Shanghai”</code>就是中国对应的时区名呢？为了查找，可以使用<code>ISO3166</code>国家代码作为关键字去查阅字典<code>pytz.country_timezones</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Urumqi  乌鲁木齐（新疆首府）</span></span><br><span class="line"><span class="built_in">print</span>(pytz.country_timezones[<span class="string">&#x27;CN&#x27;</span>])  <span class="comment"># Prints [&#x27;Asia/Shanghai&#x27;, &#x27;Asia/Urumqi&#x27;]</span></span><br></pre></td></tr></table></figure>

<h3 id="迭代器与生成器"><a href="#迭代器与生成器" class="headerlink" title="迭代器与生成器"></a>迭代器与生成器</h3><h4 id="代理迭代"><a href="#代理迭代" class="headerlink" title="代理迭代"></a>代理迭代</h4><p>Python的迭代器协议需要<code>__iter__()</code>方法返回一个实现了<code>__next__()</code>方法的迭代器对象。如果你只是迭代遍历其他容器的内容，你无须担心底层是怎样实现的。你所要做的只是传递迭代请求既可。这里的<code>iter()</code>函数的使用简化了代码，<code>iter(s)</code>只是简单的通过调用<code>s.__iter__()</code>方法来返回对应的迭代器对象，就跟<code>len(s)</code>会调用<code>s.__len__()</code>原理是一样的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding: UTF-8</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Created on 2015/7/4  18:33</span></span><br><span class="line"><span class="string">@author: &#x27;WX&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self._value = value</span><br><span class="line">        self._children = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Node(&#123;!r&#125;)&#x27;</span>.<span class="built_in">format</span>(self._value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_child</span>(<span class="params">self, node</span>):</span><br><span class="line">        self._children.append(node)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iter</span>(self._children)</span><br><span class="line"><span class="comment">#Example</span></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    root = Node(<span class="number">0</span>)</span><br><span class="line">    child1 = Node(<span class="number">1</span>)</span><br><span class="line">    child2 = Node(<span class="number">2</span>)</span><br><span class="line">    root.add_child(child1)</span><br><span class="line">    root.add_child(child2)</span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> root:</span><br><span class="line">        <span class="built_in">print</span>(ch)</span><br></pre></td></tr></table></figure>
<h4 id="反向迭代"><a href="#反向迭代" class="headerlink" title="反向迭代"></a>反向迭代</h4><p>反向迭代仅仅当对象的大小可预先确定或者对象实现了<code>__reversed__()</code>的特殊方法时才能生效。如果两者都不符合，那你必须先将对象转换为一个列表才行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">reversed</span>(a):</span><br><span class="line">    <span class="built_in">print</span>(x, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="comment"># Print a file backwards</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;test.csv&#x27;</span>, mode=<span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">list</span>(f)):</span><br><span class="line">    <span class="built_in">print</span>(line, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要注意的是如果可迭代对象元素很多的话，将其预先转换为一个列表要消耗大量的内存。这时候需要在定义的类上实现<code>__reversed__()</code>方法来实现反向迭代</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Countdown</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, start</span>):</span><br><span class="line">        self.start = start</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Forward iterator</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        n = self.start</span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">yield</span> n</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Reverse iterator</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reversed__</span>(<span class="params">self</span>):</span><br><span class="line">        n = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> n &lt;= self.start:</span><br><span class="line">            <span class="keyword">yield</span> n</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> rr <span class="keyword">in</span> <span class="built_in">reversed</span>(Countdown(<span class="number">30</span>)):</span><br><span class="line">    <span class="built_in">print</span>(rr)</span><br><span class="line"><span class="keyword">for</span> rr <span class="keyword">in</span> Countdown(<span class="number">30</span>):</span><br><span class="line">    <span class="built_in">print</span>(rr)</span><br></pre></td></tr></table></figure>
<p>定义一个反向迭代器可以使得代码非常的高效，因为它不再需要将数据填充到一个列表中然后再去反向迭代这个列表。</p>
<h4 id="迭代器切片"><a href="#迭代器切片" class="headerlink" title="迭代器切片"></a>迭代器切片</h4><p>函数<code>itertools.islice()</code>正好适用于在迭代器和生成器上做切片操作</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">n</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">yield</span> n</span><br><span class="line"><span class="meta">... </span>        n += <span class="number">1</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = count(<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c[<span class="number">10</span>:<span class="number">20</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">&#x27;generator&#x27;</span> <span class="built_in">object</span> <span class="keyword">is</span> <span class="keyword">not</span> subscriptable</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Now using islice()</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> itertools</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> itertools.islice(c, <span class="number">10</span>, <span class="number">20</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(x)</span><br><span class="line">...</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">19</span></span><br></pre></td></tr></table></figure>
<p>函数<code>islice()</code>返回一个可以生成指定元素的迭代器，它通过遍历并丢弃直到切片开始索引位置的所有元素。然后才开始一个个的返回元素，并直到切片结束索引位置。这里要着重强调的一点是<code>islice()</code>会消耗掉传入的迭代器中的数据。必须考虑到迭代器是不可逆的这个事实。所以如果你需要之后再次访问这个迭代器的话，那你就得先将它里面的数据放入一个列表中。</p>
<h4 id="跳过可迭代对象的开始部分"><a href="#跳过可迭代对象的开始部分" class="headerlink" title="跳过可迭代对象的开始部分"></a>跳过可迭代对象的开始部分</h4><p>为了演示，假定你在读取一个开始部分是几行注释的源文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/etc/passwd&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="meta">... </span><span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(line, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment"># User Database</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Note that this file is consulted directly only when the system is running</span></span><br><span class="line"><span class="comment"># in single-user mode. At other times, this information is provided by</span></span><br><span class="line"><span class="comment"># Open Directory.</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">##</span></span><br><span class="line">nobody:*:-<span class="number">2</span>:-<span class="number">2</span>:Unprivileged User:/var/empty:/usr/<span class="built_in">bin</span>/false</span><br><span class="line">root:*:<span class="number">0</span>:<span class="number">0</span>:System Administrator:/var/root:/<span class="built_in">bin</span>/sh</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>如果你想跳过开始部分的注释行的话，可以这样做</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> itertools <span class="keyword">import</span> dropwhile</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/etc/passwd&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> line <span class="keyword">in</span> dropwhile(<span class="keyword">lambda</span> line: line.startswith(<span class="string">&#x27;#&#x27;</span>), f):</span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(line, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">...</span><br><span class="line">nobody:*:-<span class="number">2</span>:-<span class="number">2</span>:Unprivileged User:/var/empty:/usr/<span class="built_in">bin</span>/false</span><br><span class="line">root:*:<span class="number">0</span>:<span class="number">0</span>:System Administrator:/var/root:/<span class="built_in">bin</span>/sh</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="排列组合的迭代"><a href="#排列组合的迭代" class="headerlink" title="排列组合的迭代"></a>排列组合的迭代</h4><p><code>itertools</code>模块提供了三个函数来解决这类问题。其中一个是<code>itertools.permutations()</code>，它接受一个集合并产生一个元组序列，每个元组由集合中所有元素的一个可能排列组成。也就是说通过打乱集合中元素排列顺序生成一个元组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>items = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> itertools <span class="keyword">import</span> permutations</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> p <span class="keyword">in</span> permutations(items):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(p)</span><br><span class="line">...</span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>如果你想得到指定长度的所有排列，你可以传递一个可选的长度参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> p <span class="keyword">in</span> permutations(items, <span class="number">2</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(p)</span><br><span class="line">...</span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>使用<code>itertools.combinations()</code>可得到输入集合中元素的所有的组合</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> itertools <span class="keyword">import</span> combinations</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> c <span class="keyword">in</span> combinations(items, <span class="number">3</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(c)</span><br><span class="line">...</span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> c <span class="keyword">in</span> combinations(items, <span class="number">2</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(c)</span><br><span class="line">...</span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> c <span class="keyword">in</span> combinations(items, <span class="number">1</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(c)</span><br><span class="line">...</span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;b&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;c&#x27;</span>,)</span><br></pre></td></tr></table></figure>
<p>对于<code>combinations()</code>来讲，元素的顺序已经不重要了。也就是说，组合<code>(&#39;a&#39;, &#39;b&#39;)</code>跟<code>(&#39;b&#39;, &#39;a&#39;)</code>其实是一样的(最终只会输出其中一个)。</p>
<p>在计算组合的时候，一旦元素被选取就会从候选中剔除掉(比如如果元素’a’已经被选取了，那么接下来就不会再考虑它了)。而函数<code>itertools.combinations_with_replacement()</code>允许同一个元素被选择多次</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> c <span class="keyword">in</span> combinations_with_replacement(items, <span class="number">3</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(c)</span><br><span class="line">...</span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="序列上索引值迭代"><a href="#序列上索引值迭代" class="headerlink" title="序列上索引值迭代"></a>序列上索引值迭代</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_list = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> idx, val <span class="keyword">in</span> <span class="built_in">enumerate</span>(my_list):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(idx, val)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> a</span><br><span class="line"><span class="number">1</span> b</span><br><span class="line"><span class="number">2</span> c</span><br></pre></td></tr></table></figure>
<p>为了按传统行号输出(行号从1开始)，你可以传递一个开始参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_list = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> idx, val <span class="keyword">in</span> <span class="built_in">enumerate</span>(my_list, <span class="number">1</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(idx, val)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span> a</span><br><span class="line"><span class="number">2</span> b</span><br><span class="line"><span class="number">3</span> c</span><br></pre></td></tr></table></figure>
<p><code>enumerate()</code>对于跟踪某些值在列表中出现的位置是很有用的。 所以，如果你想将一个文件中出现的单词映射到它出现的行号上去，可以很容易的利用<code>enumerate()</code>来完成</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">word_summary = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;myfile.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    lines = f.readlines()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> idx, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(lines):</span><br><span class="line">    <span class="comment"># Create a list of words in current line</span></span><br><span class="line">    words = [w.strip().lower() <span class="keyword">for</span> w <span class="keyword">in</span> line.split()]</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">        word_summary[word].append(idx)</span><br></pre></td></tr></table></figure>
<p>如果你处理完文件后打印 <code>word_summary</code>，会发现它是一个字典(准确来讲是一个<code>defaultdict</code>)，对于每个单词有一个<code>key</code>，每个<code>key</code>对应的值是一个由这个单词出现的行号组成的列表。如果某个单词在一行中出现过两次，那么这个行号也会出现两次，同时也可以作为文本的一个简单统计。</p>
<p><code>enumerate()</code>函数返回的是一个<code>enumerate</code>对象实例，它是一个迭代器，返回连续的包含一个计数和一个值的元组，元组中的值通过在传入序列上调用<code>next()</code>返回。</p>
<p>还有一点可能并不很重要，但是也值得注意，有时候当你在一个已经解压后的元组序列上使用<code>enumerate()</code>函数时很容易调入陷阱。你得像下面正确的方式这样写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data = [ (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">6</span>), (<span class="number">7</span>, <span class="number">8</span>) ]</span><br><span class="line"><span class="comment"># Correct!</span></span><br><span class="line"><span class="keyword">for</span> n, (x, y) <span class="keyword">in</span> <span class="built_in">enumerate</span>(data):</span><br><span class="line">    ...</span><br><span class="line"><span class="comment"># Error!</span></span><br><span class="line"><span class="keyword">for</span> n, x, y <span class="keyword">in</span> <span class="built_in">enumerate</span>(data):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<h4 id="同时迭代多个序列"><a href="#同时迭代多个序列" class="headerlink" title="同时迭代多个序列"></a>同时迭代多个序列</h4><p>为了同时迭代多个序列，使用<code>zip()</code>函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>xpts = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">7</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ypts = [<span class="number">101</span>, <span class="number">78</span>, <span class="number">37</span>, <span class="number">15</span>, <span class="number">62</span>, <span class="number">99</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(xpts, ypts):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(x,y)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span> <span class="number">101</span></span><br><span class="line"><span class="number">5</span> <span class="number">78</span></span><br><span class="line"><span class="number">4</span> <span class="number">37</span></span><br><span class="line"><span class="number">2</span> <span class="number">15</span></span><br><span class="line"><span class="number">10</span> <span class="number">62</span></span><br><span class="line"><span class="number">7</span> <span class="number">99</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p><code>zip(a, b)</code>会生成一个可返回元组<code>(x, y)</code>的迭代器，其中<code>x</code>来自<code>a</code>，<code>y</code>来自<code>b</code>。一旦其中某个序列到底结尾，迭代宣告结束。因此迭代长度跟参数中最短序列长度一致。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">zip</span>(a,b):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(i)</span><br><span class="line">...</span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;y&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>如果这个不是你想要的效果，那么还可以使用<code>itertools.zip_longest()</code>函数来代替。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> itertools <span class="keyword">import</span> zip_longest</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> zip_longest(a,b):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(i)</span><br><span class="line">...</span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">(<span class="literal">None</span>, <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> zip_longest(a, b, fillvalue=<span class="number">0</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(i)</span><br><span class="line">...</span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">(<span class="number">0</span>, <span class="string">&#x27;z&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>最后强调一点就是，<code>zip()</code>会创建一个迭代器来作为结果返回。如果你需要将结对的值存储在列表中，要使用<code>list()</code>函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">zip</span>(a, b)</span><br><span class="line">&lt;<span class="built_in">zip</span> <span class="built_in">object</span> at <span class="number">0x1007001b8</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">zip</span>(a, b))</span><br><span class="line">[(<span class="number">1</span>, <span class="number">10</span>), (<span class="number">2</span>, <span class="number">11</span>), (<span class="number">3</span>, <span class="number">12</span>)]</span><br></pre></td></tr></table></figure>
<h4 id="不同集合上元素的迭代"><a href="#不同集合上元素的迭代" class="headerlink" title="不同集合上元素的迭代"></a>不同集合上元素的迭代</h4><p>当可迭代对象类型不一样的时候<code>chain()</code>同样可以很好的工作，它接受一个可迭代对象列表作为输入，并返回一个迭代器，有效的屏蔽掉在多个容器中迭代细节。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> itertools <span class="keyword">import</span> chain</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> chain(a, b):</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(x)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">x</span><br><span class="line">y</span><br><span class="line">z</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h4 id="展开嵌套的序列"><a href="#展开嵌套的序列" class="headerlink" title="展开嵌套的序列"></a>展开嵌套的序列</h4><p>可以写一个包含<code>yield from</code>语句的递归生成器来轻松解决这个问题</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">flatten</span>(<span class="params">items, ignore_types=(<span class="params"><span class="built_in">str</span>, <span class="built_in">bytes</span></span>)</span>):</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> items:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(x, Iterable) <span class="keyword">and</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(x, ignore_types):</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> flatten(x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">yield</span> x</span><br><span class="line"></span><br><span class="line">items = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>], <span class="number">7</span>], <span class="number">8</span>]</span><br><span class="line"><span class="comment"># Produces 1 2 3 4 5 6 7 8</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> flatten(items):</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure>
<p>额外的参数<code>ignore_types</code>和检测语句<code>isinstance(x,ignore_types)</code>用来将字符串和字节排除在可迭代对象外，防止将它们再展开成单个的字符。这样的话字符串数组就能最终返回我们所期望的结果了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>items = [<span class="string">&#x27;Dave&#x27;</span>, <span class="string">&#x27;Paula&#x27;</span>, [<span class="string">&#x27;Thomas&#x27;</span>, <span class="string">&#x27;Lewis&#x27;</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> flatten(items):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(x)</span><br><span class="line">...</span><br><span class="line">Dave</span><br><span class="line">Paula</span><br><span class="line">Thomas</span><br><span class="line">Lewis</span><br></pre></td></tr></table></figure>
<h4 id="顺序迭代合并后的排序迭代对象"><a href="#顺序迭代合并后的排序迭代对象" class="headerlink" title="顺序迭代合并后的排序迭代对象"></a>顺序迭代合并后的排序迭代对象</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> heapq</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">11</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> c <span class="keyword">in</span> heapq.merge(a, b):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(c)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure>
<p><code>heapq.merge</code>可迭代特性意味着它不会立马读取所有序列。这就意味着你可以在非常长的序列中使用它，而不会有太大的开销。比如，下面是一个例子来演示如何合并两个排序文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;sorted_file_1&#x27;</span>, <span class="string">&#x27;rt&#x27;</span>) <span class="keyword">as</span> file1, \</span><br><span class="line">    <span class="built_in">open</span>(<span class="string">&#x27;sorted_file_2&#x27;</span>, <span class="string">&#x27;rt&#x27;</span>) <span class="keyword">as</span> file2, \</span><br><span class="line">    <span class="built_in">open</span>(<span class="string">&#x27;merged_file&#x27;</span>, <span class="string">&#x27;wt&#x27;</span>) <span class="keyword">as</span> outf:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> heapq.merge(file1, file2):</span><br><span class="line">        outf.write(line)</span><br></pre></td></tr></table></figure>
<p>有一点要强调的是<code>heapq.merge()</code>需要所有输入序列必须是排过序的。特别的，它并不会预先读取所有数据到堆栈中或者预先排序，也不会对输入做任何的排序检测。它仅仅是检查所有序列的开始部分并返回最小的那个，这个过程一直会持续直到所有输入序列中的元素都被遍历完。</p>
<p><strong>参考文献</strong><br>[1] <a target="_blank" rel="noopener" href="https://www.gitbook.com/book/lenkimo/byte-of-python-chinese-edition/details">A Byte of Python3</a><br>[2] <a target="_blank" rel="noopener" href="http://python3-cookbook.readthedocs.org/zh_CN/latest/c01/p08_calculating_with_dict.html">python3-cookbook</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.sovdating.com/Python-implementation-of-the-longest-common-subsequences/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DJY">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sovdating Linux">
      <meta itemprop="description" content="Hello dev">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sovdating Linux">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/Python-implementation-of-the-longest-common-subsequences/" class="post-title-link" itemprop="url">Python实现最长公共子序列-Longest Common Subsequences</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2015-07-03 22:34:40" itemprop="dateCreated datePublished" datetime="2015-07-03T22:34:40+08:00">2015-07-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-01-24 10:24:42" itemprop="dateModified" datetime="2024-01-24T10:24:42+08:00">2024-01-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Algorithms/" itemprop="url" rel="index"><span itemprop="name">Algorithms</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>一个数列<strong>S</strong>，如果分别是两个或多个已知数列的子序列，且是所有符合此条件序列中最长的，则<strong>S</strong>称为已知序列的最长公共子序列。例如序列<code>X=ABCBDAB</code>，<code>Y=BDCABA</code>。序列<code>BCA</code>是X和Y的一个公共子序列，但是不是X和Y的最长公共子序列，子序列<code>BCBA</code>是X和Y的一个LCS。</p>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>对于一般性的LCS问题（即任意数量的序列）是属于<code>NP-hard</code>。但当序列的数量确定时，问题可以使用动态规划（Dynamic Programming）在多项式时间解决。</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>动态规划的一个计算最长公共子序列的方法如下，以两个序列$X&#x3D;\langle x_1,x_2,…,x_m \rangle$、$Y&#x3D;\langle y_1,y_2,…,y_n \rangle$为例子，LCS(X,Y)表示X和Y的一个最长公共子序列：<br>如果$x_m &#x3D; y_n$，则$LCS(X,Y) &#x3D; x_m + LCS(x_{m-1},y_{n-1})$<br>如果$x_m !&#x3D; y_n$，则$LCS(X,Y) &#x3D; max \lbrace LCS(x_{m-1},Y)，LCS(X,y_{n-1}) \rbrace$</p>
<p>为了找到最长的LCS，我们定义<code>dp[i][j]</code>记录LCS的长度，如果X的长度为0或者Y的长度为0，那么LCS&#x3D;0，即<code>dp[i][j]=0</code>，用i和j分别表示到序列X和序列Y的长度，状态转移方程如下:</p>
<p>$$i&#x3D;0||j&#x3D;0，dp[i][j] &#x3D; 0$$</p>
<p>$$X[i] &#x3D; Y[j]，dp[i][j] &#x3D; dp[i-1][j-1] + 1$$</p>
<p>$$X[i] !&#x3D; Y[j]，dp[i][j] &#x3D; max \lbrace dp[i-1][j]，dp[i][j-1] \rbrace$$</p>
<h3 id="Python实现LCS"><a href="#Python实现LCS" class="headerlink" title="Python实现LCS"></a>Python实现LCS</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Longest Common Subsequences</span></span><br><span class="line"><span class="string">Created on 2015/7/2  15:11</span></span><br><span class="line"><span class="string">@author: Wang Xu</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LCS</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lcs_base</span>(<span class="params">self, input_x, input_y</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(input_x) == <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(input_y) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            a = input_x[<span class="number">0</span>]</span><br><span class="line">            b = input_y[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> a == b:</span><br><span class="line">                <span class="keyword">return</span> self.lcs_base(input_x[<span class="number">1</span>:], input_y[<span class="number">1</span>:]) + a</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># get the max one</span></span><br><span class="line">                <span class="keyword">return</span> self.getMax(self.lcs_base(input_x[<span class="number">1</span>:], input_y), self.lcs_base(input_x, input_y[<span class="number">1</span>:]))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># construct a list by the input string</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getList</span>(<span class="params">self, inputStr</span>):</span><br><span class="line">        listRes = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(inputStr) != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(inputStr)):</span><br><span class="line">                listRes.append(inputStr[i])</span><br><span class="line">        <span class="keyword">return</span> listRes</span><br><span class="line"></span><br><span class="line">    <span class="comment"># return the max one between a and b, equivalently return the longest one</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMax</span>(<span class="params">self, a, b</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(a) &gt;= <span class="built_in">len</span>(b):</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    lcs = LCS()</span><br><span class="line">    l1 = lcs.getList(<span class="string">&#x27;我的大中国&#x27;</span>)</span><br><span class="line">    l2 = lcs.getList(<span class="string">&#x27;大中国我的&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    l3 = lcs.lcs_base(l1, l2)</span><br><span class="line">    <span class="built_in">print</span>(l3[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    l3 = lcs.lcs_base(l2, l1)</span><br><span class="line">    <span class="built_in">print</span>(l3[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    l1 = <span class="string">&#x27;1233433236676&#x27;</span></span><br><span class="line">    l2 = <span class="string">&#x27;98723765655423&#x27;</span></span><br><span class="line">    l3 = lcs.lcs_base(l1, l2)</span><br><span class="line">    <span class="built_in">print</span>(l3[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    l1 = <span class="string">&#x27;123s212346我的大中国啊33z&#x27;</span></span><br><span class="line">    l2 = <span class="string">&#x27;33z的大中国&#x27;</span></span><br><span class="line">    l3 = lcs.lcs_base(l1, l2)</span><br><span class="line">    <span class="built_in">print</span>(l3[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p>该算法的空间、时间复杂度均为$O(n^{2})$，经过优化后，空间复杂度可为$O(n)$。</p>
<h3 id="LCS变体-最长公共子串"><a href="#LCS变体-最长公共子串" class="headerlink" title="LCS变体-最长公共子串"></a>LCS变体-最长公共子串</h3><p>最长公共子串与最长公共子序列稍有区别，不过也算是<code>LCS</code>的一个变体，在<code>LCS</code>中，子序列是不必要求连续的，而子串则是“连续”的。<br>题：给定两个字符串<code>X</code>，<code>Y</code>，求二者最长的公共子串，例如<code>X=[aaaba]</code>，<code>Y=[ababaa]</code>。二者的最长公共子串为<code>[aba]</code>，长度为3。</p>
<h4 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h4><p>将X的每个子串与Y的每个子串做对比，求出最长公共子串</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Created on 2015/7/2  16:13</span></span><br><span class="line"><span class="string">@author: Wang Xu</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 使用基本算法获取最长公共子串（连续），最长公共子序列可以是非连续的</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getcomlen</span>(<span class="params">firststr, secondstr</span>):</span><br><span class="line">    comlen = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> firststr <span class="keyword">and</span> secondstr:</span><br><span class="line">        <span class="keyword">if</span> firststr[<span class="number">0</span>] == secondstr[<span class="number">0</span>]:</span><br><span class="line">            comlen += <span class="number">1</span></span><br><span class="line">            firststr = firststr[<span class="number">1</span>:]</span><br><span class="line">            secondstr = secondstr[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> comlen</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lcs_base</span>(<span class="params">input_x, input_y</span>):</span><br><span class="line">    max_common_len = <span class="number">0</span></span><br><span class="line">    common_index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> xtemp <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(input_x)):</span><br><span class="line">        <span class="keyword">for</span> ytemp <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(input_y)):</span><br><span class="line">            com_temp = getcomlen(input_x[xtemp: <span class="built_in">len</span>(input_x)], input_y[ytemp: <span class="built_in">len</span>(input_y)])</span><br><span class="line">            <span class="keyword">if</span> com_temp &gt; max_common_len:</span><br><span class="line">                max_common_len = com_temp</span><br><span class="line">                common_index = xtemp</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;公共子串的长度是：%s&#x27;</span> % max_common_len)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;最长公共子串是：%s&#x27;</span> % input_x[common_index:common_index + max_common_len])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    lcs_base(<span class="string">&#x27;d11zabcdeabdcdbbcd&#x27;</span>, <span class="string">&#x27;bbcd11yabcdefaaa&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">OutPut:</span></span><br><span class="line"><span class="string">公共子串的长度是：5</span></span><br><span class="line"><span class="string">最长公共子串是：abcde</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="DP算法"><a href="#DP算法" class="headerlink" title="DP算法"></a>DP算法</h4><p>使用动态规划来解最长公共子串问题，可以考虑如何将<code>arr[0,...,i]</code>的问题转化为求解<code>arr[0,...,i-1]</code>的问题，此处考虑使用<code>dp[i][j]</code>表示以<code>X[i]</code>和<code>Y[j]</code>结尾的最长公共子串的长度，因为要求子串连续，所以对于<code>X[i]</code>和<code>Y[j]</code>来讲，它们要么与之前的公共子串构成新的公共子串；要么就是不构成公共子串；状态转移方程为</p>
<p>$$X[i] &#x3D; Y[j]，dp[i][j] &#x3D; dp[i-1][j-1] + 1$$</p>
<p>$$X[i] !&#x3D; Y[j]，dp[i][j] &#x3D; 0$$</p>
<p>对于初始化，<code>i=0</code>或者<code>j=0</code>，如果<code>X[i] == Y[j]</code>，<code>dp[i][j] = 1</code>；否则<code>dp[i][j] = 0</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LCS3</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lcs_dp</span>(<span class="params">self, input_x, input_y</span>):</span><br><span class="line">        <span class="comment"># input_y as column, input_x as row</span></span><br><span class="line">        dp = [([<span class="number">0</span>] * <span class="built_in">len</span>(input_y)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(input_x))]</span><br><span class="line">        maxlen = maxindex = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(input_x)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(input_y)):</span><br><span class="line">                <span class="keyword">if</span> input_x[i] == input_y[j]:</span><br><span class="line">                    <span class="keyword">if</span> i!=<span class="number">0</span> <span class="keyword">and</span> j!=<span class="number">0</span>:</span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> j == <span class="number">0</span>:</span><br><span class="line">                        dp[i][j] = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> dp[i][j] &gt; maxlen:</span><br><span class="line">                        maxlen = dp[i][j]</span><br><span class="line">                        maxindex = i + <span class="number">1</span> - maxlen</span><br><span class="line">                        <span class="comment"># print(&#x27;最长公共子串的长度是:%s&#x27; % maxlen)</span></span><br><span class="line">                        <span class="comment"># print(&#x27;最长公共子串是:%s&#x27; % input_x[maxindex:maxindex + maxlen])</span></span><br><span class="line">        <span class="keyword">return</span> input_x[maxindex:maxindex + maxlen]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    lcs3 = LCS3()</span><br><span class="line">    <span class="built_in">print</span>(lcs3.lcs_dp(<span class="string">&#x27;我是美abc国中defg国中间人&#x27;</span>, <span class="string">&#x27;abdde我是美中国中国中国人&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(lcs3.lcs_dp(<span class="string">&#x27;cabdec&#x27;</span>,<span class="string">&#x27;cbdec&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p><strong>参考文献</strong><br>[1] <a target="_blank" rel="noopener" href="http://www.ahathinking.com/archives/115.html">http://www.ahathinking.com/archives/115.html</a><br>[2] <a target="_blank" rel="noopener" href="http://dsqiu.iteye.com/blog/1701541">http://dsqiu.iteye.com/blog/1701541</a><br>[3] <a target="_blank" rel="noopener" href="http://www.ahathinking.com/archives/122.html">http://www.ahathinking.com/archives/122.html</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.sovdating.com/Python3-beginner-s-handbook-one/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DJY">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sovdating Linux">
      <meta itemprop="description" content="Hello dev">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sovdating Linux">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/Python3-beginner-s-handbook-one/" class="post-title-link" itemprop="url">Python3入门手册之一</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2015-07-02 21:41:03" itemprop="dateCreated datePublished" datetime="2015-07-02T21:41:03+08:00">2015-07-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-01-24 10:24:42" itemprop="dateModified" datetime="2024-01-24T10:24:42+08:00">2024-01-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming-Notes/" itemprop="url" rel="index"><span itemprop="name">Programming Notes</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><em>Version：Python 3.4.3 (v3.4.3:9b73f1c3e601, Feb 24 2015, 22:44:40) [MSC v.1600 64 bit (AMD64)] on win32</em></p>
<p><strong>There are two ways of constructing a software design: one way is to make it so simple that there are obviously no deficiences; the other is to make it so complicated that there are no obvious deficiences.</strong><br>—- C.A.R.Hoare</p>
<p><strong>Success in life is a matter not so much of talent and opportunity as of concentration and perseverance</strong><br>—- C.W.Wendte</p>
<h3 id="选择Python的原因"><a href="#选择Python的原因" class="headerlink" title="选择Python的原因"></a>选择Python的原因</h3><ul>
<li>简单易学，功能强大，具有高效的高层数据结构，支持面向对象编程</li>
<li>解释性语言，可扩展性，可嵌入性，丰富的库</li>
</ul>
<h3 id="选择一个编辑器"><a href="#选择一个编辑器" class="headerlink" title="选择一个编辑器"></a>选择一个编辑器</h3><p>工欲善其事必先利其器，所以选择编辑器首当其冲。</p>
<ul>
<li>IDLE：Python自带，极简利器，支持语法高亮</li>
<li>Vim&#x2F;Emacs：<code>Linux/FreeBSD</code>平台上的开发利器，二者择其一</li>
<li>PyCharm：号称最智能的Python编辑器，的确是的，但是略微复杂</li>
</ul>
<h3 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h3><h4 id="解压序列赋值给多个变量"><a href="#解压序列赋值给多个变量" class="headerlink" title="解压序列赋值给多个变量"></a>解压序列赋值给多个变量</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 变量的数量需要和序列元素的数量一致</span></span><br><span class="line">data = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line">a, b, c, d = data</span><br><span class="line"><span class="built_in">print</span>(a, b, c, d)</span><br><span class="line"></span><br><span class="line">data = [<span class="string">&#x27;ACME&#x27;</span>, <span class="number">50</span>, <span class="number">91.1</span>, (<span class="number">2012</span>, <span class="number">12</span>, <span class="number">21</span>)]</span><br><span class="line">name, shares, price, (year, month, day) = data</span><br><span class="line"><span class="built_in">print</span>(year, month, day)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压一部分，其他值丢弃</span></span><br><span class="line">data = [<span class="string">&#x27;ACME&#x27;</span>, <span class="number">50</span>, <span class="number">91.1</span>, (<span class="number">2012</span>, <span class="number">12</span>, <span class="number">21</span>)]</span><br><span class="line">_, shares, price, _ = data</span><br><span class="line"><span class="built_in">print</span>(shares, price)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只取第一个和最后一个，中间的所有元素用通配符接收</span></span><br><span class="line">record = (<span class="string">&#x27;Dave&#x27;</span>, <span class="string">&#x27;dave@example.com&#x27;</span>, <span class="string">&#x27;773-555-1212&#x27;</span>, <span class="string">&#x27;847-555-1212&#x27;</span>)</span><br><span class="line">name, *_, phone = record</span><br><span class="line"><span class="built_in">print</span>(name, phone)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">OutPut:</span></span><br><span class="line"><span class="string">a b c d</span></span><br><span class="line"><span class="string">2012 12 21</span></span><br><span class="line"><span class="string">50 91.1</span></span><br><span class="line"><span class="string">Dave 847-555-1212</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="查找最大或最小的N个元素"><a href="#查找最大或最小的N个元素" class="headerlink" title="查找最大或最小的N个元素"></a>查找最大或最小的N个元素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">23</span>, <span class="number">7</span>, -<span class="number">4</span>, <span class="number">18</span>, <span class="number">23</span>, <span class="number">42</span>, <span class="number">37</span>, <span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(heapq.nlargest(<span class="number">3</span>, nums))  <span class="comment"># Prints [42, 37, 23]</span></span><br><span class="line"><span class="built_in">print</span>(heapq.nsmallest(<span class="number">3</span>, nums))  <span class="comment"># Prints [-4, 1, 2]</span></span><br><span class="line"><span class="comment"># heapify会先将集合数据进行堆排序后放入一个列表中</span></span><br><span class="line"><span class="comment"># heappop会先将第一个元素弹出来，然后用下一个最小的元素来取代被弹出元素</span></span><br><span class="line">heapq.heapify(nums)</span><br><span class="line"><span class="built_in">print</span>(heapq.heappop(nums))  <span class="comment"># Prints -4</span></span><br><span class="line"><span class="built_in">print</span>(heapq.heappop(nums))  <span class="comment"># Prints 1</span></span><br><span class="line"><span class="built_in">print</span>(heapq.heappop(nums))  <span class="comment"># Prints 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面代码在对每个元素进行对比的时候，会以price的值进行比较。</span></span><br><span class="line">portfolio = [</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;IBM&#x27;</span>, <span class="string">&#x27;shares&#x27;</span>: <span class="number">100</span>, <span class="string">&#x27;price&#x27;</span>: <span class="number">91.1</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;AAPL&#x27;</span>, <span class="string">&#x27;shares&#x27;</span>: <span class="number">50</span>, <span class="string">&#x27;price&#x27;</span>: <span class="number">543.22</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;FB&#x27;</span>, <span class="string">&#x27;shares&#x27;</span>: <span class="number">200</span>, <span class="string">&#x27;price&#x27;</span>: <span class="number">21.09</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;HPQ&#x27;</span>, <span class="string">&#x27;shares&#x27;</span>: <span class="number">35</span>, <span class="string">&#x27;price&#x27;</span>: <span class="number">31.75</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;YHOO&#x27;</span>, <span class="string">&#x27;shares&#x27;</span>: <span class="number">45</span>, <span class="string">&#x27;price&#x27;</span>: <span class="number">16.35</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;ACME&#x27;</span>, <span class="string">&#x27;shares&#x27;</span>: <span class="number">75</span>, <span class="string">&#x27;price&#x27;</span>: <span class="number">115.65</span>&#125;</span><br><span class="line">]</span><br><span class="line">cheap = heapq.nsmallest(<span class="number">3</span>, portfolio, key=<span class="keyword">lambda</span> s: s[<span class="string">&#x27;price&#x27;</span>])</span><br><span class="line">expensive = heapq.nlargest(<span class="number">3</span>, portfolio, key=<span class="keyword">lambda</span> s: s[<span class="string">&#x27;price&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(cheap)</span><br><span class="line"><span class="built_in">print</span>(expensive)</span><br></pre></td></tr></table></figure>
<h4 id="字典操作相关"><a href="#字典操作相关" class="headerlink" title="字典操作相关"></a>字典操作相关</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 求字典中值的最小值、最大值</span></span><br><span class="line">prices = &#123;</span><br><span class="line">    <span class="string">&#x27;ACME&#x27;</span>: <span class="number">45.23</span>,</span><br><span class="line">    <span class="string">&#x27;AAPL&#x27;</span>: <span class="number">612.78</span>,</span><br><span class="line">    <span class="string">&#x27;IBM&#x27;</span>: <span class="number">205.55</span>,</span><br><span class="line">    <span class="string">&#x27;HPQ&#x27;</span>: <span class="number">37.20</span>,</span><br><span class="line">    <span class="string">&#x27;FB&#x27;</span>: <span class="number">10.75</span></span><br><span class="line">&#125;</span><br><span class="line">min_price = <span class="built_in">min</span>(<span class="built_in">zip</span>(prices.values(), prices.keys()))</span><br><span class="line"><span class="comment"># min_price is (10.75, &#x27;FB&#x27;)</span></span><br><span class="line">max_price = <span class="built_in">max</span>(<span class="built_in">zip</span>(prices.values(), prices.keys()))</span><br><span class="line"><span class="comment"># max_price is (612.78, &#x27;AAPL&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 还可以使用sorted()和zip()函数来排列字典数据</span></span><br><span class="line">prices_sorted = <span class="built_in">sorted</span>(<span class="built_in">zip</span>(prices.values(), prices.keys()))</span><br><span class="line"><span class="comment"># prices_sorted is [(10.75, &#x27;FB&#x27;), (37.2, &#x27;HPQ&#x27;),</span></span><br><span class="line"><span class="comment">#                   (45.23, &#x27;ACME&#x27;), (205.55, &#x27;IBM&#x27;),</span></span><br><span class="line"><span class="comment">#                   (612.78, &#x27;AAPL&#x27;)]</span></span><br><span class="line"><span class="comment"># 执行这些计算的时候，需要注意的是zip()函数创建的是一个只能访问一次的迭代器。 比如，下面的代码就会产生错误：</span></span><br><span class="line">prices_and_names = <span class="built_in">zip</span>(prices.values(), prices.keys())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">min</span>(prices_and_names))  <span class="comment"># OK</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(prices_and_names))  <span class="comment"># ValueError: max() arg is an empty sequence</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要注意的是在计算操作中使用到了(值，键)对。当多个实体拥有相同的值的时候，键会决定返回结果。 比如，在执行min()和max()操作的时候，如果恰巧最小或最大值有重复的，那么拥有最小或最大键的实体会返回：</span></span><br><span class="line">prices = &#123;<span class="string">&#x27;AAA&#x27;</span>: <span class="number">45.23</span>, <span class="string">&#x27;ZZZ&#x27;</span>: <span class="number">45.23</span>&#125;</span><br><span class="line"><span class="built_in">min</span>(<span class="built_in">zip</span>(prices.values(), prices.keys()))</span><br><span class="line"><span class="comment"># OutPut:(45.23, &#x27;AAA&#x27;)</span></span><br><span class="line"><span class="built_in">max</span>(<span class="built_in">zip</span>(prices.values(), prices.keys()))</span><br><span class="line"><span class="comment"># OutPut:(45.23, &#x27;ZZZ&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找两字典的相同点</span></span><br><span class="line">a = &#123;</span><br><span class="line">    <span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;y&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;z&#x27;</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b = &#123;</span><br><span class="line">    <span class="string">&#x27;w&#x27;</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="string">&#x27;x&#x27;</span>: <span class="number">11</span>,</span><br><span class="line">    <span class="string">&#x27;y&#x27;</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># Find keys in common</span></span><br><span class="line">a.keys() &amp; b.keys()  <span class="comment"># &#123; &#x27;x&#x27;, &#x27;y&#x27; &#125;</span></span><br><span class="line"><span class="comment"># Find keys in a that are not in b</span></span><br><span class="line">a.keys() - b.keys()  <span class="comment"># &#123; &#x27;z&#x27; &#125;</span></span><br><span class="line"><span class="comment"># Find (key,value) pairs in common</span></span><br><span class="line">a.items() &amp; b.items()  <span class="comment"># &#123; (&#x27;y&#x27;, 2) &#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="序列中出现次数最多的元素"><a href="#序列中出现次数最多的元素" class="headerlink" title="序列中出现次数最多的元素"></a>序列中出现次数最多的元素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">words = [</span><br><span class="line">    <span class="string">&#x27;look&#x27;</span>, <span class="string">&#x27;into&#x27;</span>, <span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;eyes&#x27;</span>, <span class="string">&#x27;look&#x27;</span>, <span class="string">&#x27;into&#x27;</span>, <span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;eyes&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;the&#x27;</span>, <span class="string">&#x27;eyes&#x27;</span>, <span class="string">&#x27;the&#x27;</span>, <span class="string">&#x27;eyes&#x27;</span>, <span class="string">&#x27;the&#x27;</span>, <span class="string">&#x27;eyes&#x27;</span>, <span class="string">&#x27;not&#x27;</span>, <span class="string">&#x27;around&#x27;</span>, <span class="string">&#x27;the&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;eyes&#x27;</span>, <span class="string">&quot;don&#x27;t&quot;</span>, <span class="string">&#x27;look&#x27;</span>, <span class="string">&#x27;around&#x27;</span>, <span class="string">&#x27;the&#x27;</span>, <span class="string">&#x27;eyes&#x27;</span>, <span class="string">&#x27;look&#x27;</span>, <span class="string">&#x27;into&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;eyes&#x27;</span>, <span class="string">&quot;you&#x27;re&quot;</span>, <span class="string">&#x27;under&#x27;</span></span><br><span class="line">]</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">word_counts = Counter(words)</span><br><span class="line"><span class="comment"># 出现频率最高的3个单词</span></span><br><span class="line">top_three = word_counts.most_common(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(top_three)</span><br><span class="line"><span class="comment"># Outputs [(&#x27;eyes&#x27;, 8), (&#x27;the&#x27;, 5), (&#x27;look&#x27;, 4)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Counter 对象可以接受任意的 hashable 序列对象。 在底层实现上，一个 Counter 对象就是一个字典，将元素映射到它出现的次数上</span></span><br><span class="line"><span class="built_in">print</span>(word_counts[<span class="string">&#x27;not&#x27;</span>])  <span class="comment"># Prints 1</span></span><br><span class="line"><span class="built_in">print</span>(word_counts[<span class="string">&#x27;eyes&#x27;</span>])  <span class="comment"># Prints 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意，对于Counter对象可以直接进行数学运算操作</span></span><br><span class="line">test = Counter([<span class="string">&#x27;addone&#x27;</span>])</span><br><span class="line">word_counts = word_counts + test</span><br><span class="line"><span class="built_in">print</span>(word_counts)</span><br><span class="line">word_counts = word_counts - test</span><br><span class="line"><span class="built_in">print</span>(word_counts)</span><br></pre></td></tr></table></figure>

<h4 id="通过某个关键字排序一个字典列表"><a href="#通过某个关键字排序一个字典列表" class="headerlink" title="通过某个关键字排序一个字典列表"></a>通过某个关键字排序一个字典列表</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过某个关键字排序一个字典列表</span></span><br><span class="line">rows = [</span><br><span class="line">    &#123;<span class="string">&#x27;fname&#x27;</span>: <span class="string">&#x27;Brian&#x27;</span>, <span class="string">&#x27;lname&#x27;</span>: <span class="string">&#x27;Jones&#x27;</span>, <span class="string">&#x27;uid&#x27;</span>: <span class="number">1003</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;fname&#x27;</span>: <span class="string">&#x27;David&#x27;</span>, <span class="string">&#x27;lname&#x27;</span>: <span class="string">&#x27;Beazley&#x27;</span>, <span class="string">&#x27;uid&#x27;</span>: <span class="number">1002</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;fname&#x27;</span>: <span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;lname&#x27;</span>: <span class="string">&#x27;Cleese&#x27;</span>, <span class="string">&#x27;uid&#x27;</span>: <span class="number">1001</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;fname&#x27;</span>: <span class="string">&#x27;Big&#x27;</span>, <span class="string">&#x27;lname&#x27;</span>: <span class="string">&#x27;Jones&#x27;</span>, <span class="string">&#x27;uid&#x27;</span>: <span class="number">1004</span>&#125;</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 根据任意的字典字段来排序输入结果行是很容易实现的，代码示例：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line"></span><br><span class="line">rows_by_fname = <span class="built_in">sorted</span>(rows, key=itemgetter(<span class="string">&#x27;fname&#x27;</span>))</span><br><span class="line">rows_by_uid = <span class="built_in">sorted</span>(rows, key=itemgetter(<span class="string">&#x27;uid&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(rows_by_fname)</span><br><span class="line"><span class="built_in">print</span>(rows_by_uid)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 排序不支持原生比较的对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, userId</span>):</span><br><span class="line">        self.userId = userId</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;User(&#123;&#125;)&#x27;</span>.<span class="built_in">format</span>(self.userId)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> attrgetter</span><br><span class="line"></span><br><span class="line">users = [User(<span class="number">23</span>), User(<span class="number">28</span>), User(<span class="number">26</span>)]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(users, key=attrgetter(<span class="string">&#x27;userId&#x27;</span>)))</span><br></pre></td></tr></table></figure>
<h4 id="通过某个字段将记录分组"><a href="#通过某个字段将记录分组" class="headerlink" title="通过某个字段将记录分组"></a>通过某个字段将记录分组</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">rows = [</span><br><span class="line">    &#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;5412 N CLARK&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/01/2012&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;5148 N CLARK&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/04/2012&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;5800 E 58TH&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/02/2012&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;2122 N CLARK&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/03/2012&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;5645 N RAVENSWOOD&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/02/2012&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;1060 W ADDISON&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/02/2012&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;4801 N BROADWAY&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/01/2012&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;1039 W GRANVILLE&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/04/2012&#x27;</span>&#125;,</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 现在假设你想在按date分组后的数据块上进行迭代。为了这样做，你首先需要按照指定的字段(这里就是date)排序， 然后调用 itertools.groupby() 函数：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> groupby</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sort by the desired field first</span></span><br><span class="line">rows.sort(key=itemgetter(<span class="string">&#x27;date&#x27;</span>))</span><br><span class="line"><span class="comment"># Iterate in groups</span></span><br><span class="line"><span class="keyword">for</span> date, items <span class="keyword">in</span> groupby(rows, key=itemgetter(<span class="string">&#x27;date&#x27;</span>)):</span><br><span class="line">    <span class="built_in">print</span>(date)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> items:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span>, i)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">OutPut:</span></span><br><span class="line"><span class="string">07/01/2012</span></span><br><span class="line"><span class="string">  &#123;&#x27;date&#x27;: &#x27;07/01/2012&#x27;, &#x27;address&#x27;: &#x27;5412 N CLARK&#x27;&#125;</span></span><br><span class="line"><span class="string">  &#123;&#x27;date&#x27;: &#x27;07/01/2012&#x27;, &#x27;address&#x27;: &#x27;4801 N BROADWAY&#x27;&#125;</span></span><br><span class="line"><span class="string">07/02/2012</span></span><br><span class="line"><span class="string">  &#123;&#x27;date&#x27;: &#x27;07/02/2012&#x27;, &#x27;address&#x27;: &#x27;5800 E 58TH&#x27;&#125;</span></span><br><span class="line"><span class="string">  &#123;&#x27;date&#x27;: &#x27;07/02/2012&#x27;, &#x27;address&#x27;: &#x27;5645 N RAVENSWOOD&#x27;&#125;</span></span><br><span class="line"><span class="string">  &#123;&#x27;date&#x27;: &#x27;07/02/2012&#x27;, &#x27;address&#x27;: &#x27;1060 W ADDISON&#x27;&#125;</span></span><br><span class="line"><span class="string">07/03/2012</span></span><br><span class="line"><span class="string">  &#123;&#x27;date&#x27;: &#x27;07/03/2012&#x27;, &#x27;address&#x27;: &#x27;2122 N CLARK&#x27;&#125;</span></span><br><span class="line"><span class="string">07/04/2012</span></span><br><span class="line"><span class="string">  &#123;&#x27;date&#x27;: &#x27;07/04/2012&#x27;, &#x27;address&#x27;: &#x27;5148 N CLARK&#x27;&#125;</span></span><br><span class="line"><span class="string">  &#123;&#x27;date&#x27;: &#x27;07/04/2012&#x27;, &#x27;address&#x27;: &#x27;1039 W GRANVILLE&#x27;&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="过滤序列元素"><a href="#过滤序列元素" class="headerlink" title="过滤序列元素"></a>过滤序列元素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">values = [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;-3&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;N/A&#x27;</span>, <span class="string">&#x27;5&#x27;</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_int</span>(<span class="params">val</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        x = <span class="built_in">int</span>(val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">ivals = <span class="built_in">list</span>(<span class="built_in">filter</span>(is_int, values))</span><br><span class="line"><span class="built_in">print</span>(ivals)</span><br><span class="line"><span class="comment"># Outputs [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;-3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;]</span></span><br></pre></td></tr></table></figure>
<h4 id="转换并同时计算数据"><a href="#转换并同时计算数据" class="headerlink" title="转换并同时计算数据"></a>转换并同时计算数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Determine if any .py files exist in a directory</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">files = os.listdir(<span class="string">&#x27;dirname&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">any</span>(name.endswith(<span class="string">&#x27;.py&#x27;</span>) <span class="keyword">for</span> name <span class="keyword">in</span> files):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;There be python!&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Sorry, no python.&#x27;</span>)</span><br><span class="line"><span class="comment"># Output a tuple as CSV</span></span><br><span class="line">s = (<span class="string">&#x27;ACME&#x27;</span>, <span class="number">50</span>, <span class="number">123.45</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;,&#x27;</span>.join(<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> s)) <span class="comment"># Prints ACME,50,123.45</span></span><br><span class="line"><span class="comment"># Data reduction across fields of a data structure</span></span><br><span class="line">portfolio = [</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;GOOG&#x27;</span>, <span class="string">&#x27;shares&#x27;</span>: <span class="number">50</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;YHOO&#x27;</span>, <span class="string">&#x27;shares&#x27;</span>: <span class="number">75</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;AOL&#x27;</span>, <span class="string">&#x27;shares&#x27;</span>: <span class="number">20</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;SCOX&#x27;</span>, <span class="string">&#x27;shares&#x27;</span>: <span class="number">65</span>&#125;</span><br><span class="line">]</span><br><span class="line">min_shares = <span class="built_in">min</span>(s[<span class="string">&#x27;shares&#x27;</span>] <span class="keyword">for</span> s <span class="keyword">in</span> portfolio)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Original: Returns 20</span></span><br><span class="line">min_shares = <span class="built_in">min</span>(s[<span class="string">&#x27;shares&#x27;</span>] <span class="keyword">for</span> s <span class="keyword">in</span> portfolio)</span><br><span class="line"><span class="comment"># Alternative: Returns &#123;&#x27;name&#x27;: &#x27;AOL&#x27;, &#x27;shares&#x27;: 20&#125;</span></span><br><span class="line">min_shares = <span class="built_in">min</span>(portfolio, key=<span class="keyword">lambda</span> s: s[<span class="string">&#x27;shares&#x27;</span>])</span><br></pre></td></tr></table></figure>
<h4 id="合并多个字典或映射"><a href="#合并多个字典或映射" class="headerlink" title="合并多个字典或映射"></a>合并多个字典或映射</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;z&#x27;</span>: <span class="number">3</span> &#125;</span><br><span class="line">b = &#123;<span class="string">&#x27;y&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;z&#x27;</span>: <span class="number">4</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> ChainMap</span><br><span class="line">c = ChainMap(a,b)</span><br><span class="line"><span class="built_in">print</span>(c[<span class="string">&#x27;x&#x27;</span>]) <span class="comment"># Outputs 1 (from a)</span></span><br><span class="line"><span class="built_in">print</span>(c[<span class="string">&#x27;y&#x27;</span>]) <span class="comment"># Outputs 2 (from b)</span></span><br><span class="line"><span class="built_in">print</span>(c[<span class="string">&#x27;z&#x27;</span>]) <span class="comment"># Outputs 3 (from a)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ChianMap使用原来的字典，它自己不创建新的字典。所以它并不会产生上面所说的结果，比如：</span></span><br><span class="line"></span><br><span class="line">a[<span class="string">&#x27;x&#x27;</span>] = <span class="number">42</span></span><br><span class="line"><span class="built_in">print</span>(c[<span class="string">&#x27;x&#x27;</span>]) <span class="comment"># Outputs 42 (from a)</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串和文本"><a href="#字符串和文本" class="headerlink" title="字符串和文本"></a>字符串和文本</h3><h4 id="使用多个界定符分割字符串"><a href="#使用多个界定符分割字符串" class="headerlink" title="使用多个界定符分割字符串"></a>使用多个界定符分割字符串</h4><p><code>string</code>对象的<code>split()</code>方法只适应于非常简单的字符串分割情形，它并不允许有多个分隔符或者是分隔符周围不确定的空格。当你需要更加灵活的切割字符串的时候，最好使用<code>re.split()</code>方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">line = <span class="string">&#x27;abcd efg; hijk , lmn&#x27;</span></span><br><span class="line">res = re.split(<span class="string">r&#x27;[;,\s]\s*&#x27;</span>, line)</span><br><span class="line"><span class="built_in">print</span>(res) <span class="comment"># Prints [&#x27;abcd&#x27;, &#x27;efg&#x27;, &#x27;hijk&#x27;, &#x27;&#x27;, &#x27;lmn&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>函数<code>re.split()</code>是非常实用的，因为它允许你为分隔符指定多个正则模式。比如，在上面的例子中，分隔符可以是逗号(,)，分号(;)或者是空格，并且后面紧跟着任意个的空格。只要这个模式被找到，那么匹配的分隔符两边的实体都会被当成是结果中的元素返回。 返回结果为一个字段列表，这个跟<code>str.split()</code>返回值类型是一样的。<br>当你使用<code>re.split()</code>函数时候，需要特别注意的是正则表达式中是否包含一个括号捕获分组。如果使用了捕获分组，那么被匹配的文本也将出现在结果列表中。比如，观察一下这段代码运行后的结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fields = re.split(<span class="string">r&#x27;(;|,|\s)\s*&#x27;</span>, line)</span><br><span class="line"><span class="built_in">print</span>(fields) <span class="comment"># Prints [&#x27;abcd&#x27;, &#x27; &#x27;, &#x27;efg&#x27;, &#x27;;&#x27;, &#x27;hijk&#x27;, &#x27; &#x27;, &#x27;&#x27;, &#x27;,&#x27;, &#x27;lmn&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>如果你不想保留分割字符串到结果列表中去，但仍然需要使用到括号来分组正则表达式的话，确保你的分组是非捕获分组，形如<code>(?:...)</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res = re.split(<span class="string">r&#x27;(?:,|;|\s)\s*&#x27;</span>, line)</span><br><span class="line"><span class="built_in">print</span>(res) <span class="comment"># Prints [&#x27;abcd&#x27;, &#x27;efg&#x27;, &#x27;hijk&#x27;, &#x27;&#x27;, &#x27;lmn&#x27;]</span></span><br></pre></td></tr></table></figure>
<h4 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查多种匹配可能，需要将所有的匹配项放入到一个元组中，然后传给startswith()或者endswith()方法</span></span><br><span class="line">strs = <span class="built_in">list</span>()</span><br><span class="line">strs.append(<span class="string">&#x27;a.txt&#x27;</span>)</span><br><span class="line">strs.append(<span class="string">&#x27;b.doc&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">    <span class="comment"># startswith方法类似</span></span><br><span class="line">    <span class="keyword">if</span> s.endswith((<span class="string">&#x27;.txt&#x27;</span>, <span class="string">&#x27;.doc&#x27;</span>)):</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">str</span>(s))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 请注意，该方法必须接收一个元组作为输入参数，如果你有一个list或者set类型的选择项，需要先调用tuple()将其转换为元组类型</span></span><br><span class="line">choices = [<span class="string">&#x27;.txt&#x27;</span>, <span class="string">&#x27;.doc&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">    <span class="keyword">if</span> s.endswith(<span class="built_in">tuple</span>(choices)):</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">str</span>(s))</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># fnmatch和fnmatchcase的使用</span></span><br><span class="line"><span class="keyword">from</span> fnmatch <span class="keyword">import</span> fnmatch, fnmatchcase</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(fnmatch(<span class="string">&#x27;foo.txt&#x27;</span>, <span class="string">&#x27;*.TXT&#x27;</span>))  <span class="comment"># On OS X (Mac) Prints False</span></span><br><span class="line"><span class="built_in">print</span>(fnmatch(<span class="string">&#x27;foo.txt&#x27;</span>, <span class="string">&#x27;*.TXT&#x27;</span>))  <span class="comment"># On Windows Prints True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 完全使用你的模式大小写进行匹配</span></span><br><span class="line"><span class="built_in">print</span>(fnmatchcase(<span class="string">&#x27;foo.txt&#x27;</span>, <span class="string">&#x27;*.TXT&#x27;</span>))  <span class="comment"># Prints False</span></span><br></pre></td></tr></table></figure>
<h4 id="字符串搜索和替换"><a href="#字符串搜索和替换" class="headerlink" title="字符串搜索和替换"></a>字符串搜索和替换</h4><p>一个替换回调函数的参数是一个<code>match</code>对象，也就是<code>match()</code>或者<code>find()</code>返回的对象。使用<code>group()</code>方法来提取特定的匹配部分。回调函数最后返回替换字符串。如果除了替换后的结果外，你还想知道有多少替换发生了，可以使用<code>re.subn()</code>来代替。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用re模块进行匹配和搜索</span></span><br><span class="line">text = <span class="string">&#x27;Today is 11/27/2012. PyCon starts 3/13/2013.&#x27;</span></span><br><span class="line">datepat = re.<span class="built_in">compile</span>(<span class="string">r&#x27;(\d+)/(\d+)/(\d+)&#x27;</span>)</span><br><span class="line">list_match = datepat.findall(text)  <span class="comment"># findall方法返回的是所有匹配的列表</span></span><br><span class="line"><span class="built_in">print</span>(list_match)</span><br><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> datepat.finditer(text):  <span class="comment"># finditer方法返回的是迭代器</span></span><br><span class="line">    <span class="built_in">print</span>(m.groups())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意点，在正则的开头字母‘r’是指定不去解析反斜杠</span></span><br><span class="line"><span class="comment"># r&#x27;(\d+)/(\d+)/(\d+)&#x27; 相当于 &#x27;(\\d+)/(\\d+)/(\\d+)&#x27;</span></span><br><span class="line">m = datepat.<span class="keyword">match</span>(<span class="string">&#x27;11/27/2012&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(m.group(<span class="number">0</span>))  <span class="comment"># Prints 11/27/2012</span></span><br><span class="line"><span class="built_in">print</span>(m.group(<span class="number">1</span>))  <span class="comment"># Prints 11</span></span><br><span class="line"><span class="built_in">print</span>(m.group(<span class="number">2</span>))  <span class="comment"># Prints 27</span></span><br><span class="line"><span class="built_in">print</span>(m.group(<span class="number">3</span>))  <span class="comment"># Prints 2012</span></span><br><span class="line"></span><br><span class="line">newtext, n = datepat.subn(<span class="string">r&#x27;\3-\1-\2&#x27;</span>, text)</span><br><span class="line"><span class="built_in">print</span>(newtext)  <span class="comment"># Prints Today is 2012-11-27. PyCon starts 2013-3-13.</span></span><br><span class="line"><span class="built_in">print</span>(n)  <span class="comment"># Prints 2</span></span><br></pre></td></tr></table></figure>

<p>为了在文本操作时忽略大小写，你需要在使用re模块的时候给这些操作提供<code>re.IGNORECASE</code>标志参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">text = <span class="string">&#x27;UPPER PYTHON, lower python, Mixed Python&#x27;</span></span><br><span class="line">re.findall(<span class="string">&#x27;python&#x27;</span>, text, flags=re.IGNORECASE) <span class="comment"># [&#x27;PYTHON&#x27;, &#x27;python&#x27;, &#x27;Python&#x27;]</span></span><br><span class="line">re.sub(<span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;snake&#x27;</span>, text, flags=re.IGNORECASE) <span class="comment"># &#x27;UPPER snake, lower snake, Mixed snake&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="最短匹配模式"><a href="#最短匹配模式" class="headerlink" title="最短匹配模式"></a>最短匹配模式</h4><p>在这个例子中，模式<code>r&#39;\&quot;(.*)\&quot;&#39;</code>的意图是匹配被双引号包含的文本。但是在正则表达式中*操作符是贪婪的，因此匹配操作会查找最长的可能匹配。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str_pat = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\&quot;(.*)\&quot;&#x27;</span>)</span><br><span class="line">text = <span class="string">&#x27;Computer says &quot;no.&quot; Phone says &quot;yes.&quot;&#x27;</span></span><br><span class="line">str_pat.findall(text)  <span class="comment"># [&#x27;no.&quot; Phone says &quot;yes.&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果希望获取最短匹配的结果，需要添加&#x27;?&#x27;</span></span><br><span class="line">str_pat = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\&quot;(.*?)\&quot;&#x27;</span>)</span><br><span class="line">str_pat.findall(text)  <span class="comment"># [&#x27;no.&#x27;, &#x27;yes.&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>这样就使得匹配变成非贪婪模式，从而得到最短的匹配，也就是我们想要的结果。</p>
<h4 id="多行匹配模式"><a href="#多行匹配模式" class="headerlink" title="多行匹配模式"></a>多行匹配模式</h4><p>这个问题很典型的出现在当你用点(.)去匹配任意字符的时候，忘记了点(.)不能匹配换行符的事实。为了修正这个问题，你可以修改模式字符串，增加对换行的支持。比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">text = <span class="string">&#x27;&#x27;&#x27;/* this is a</span></span><br><span class="line"><span class="string">multiline comment */</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">comment = re.<span class="built_in">compile</span>(<span class="string">r&#x27;/\*((?:.|\n)*?)\*/&#x27;</span>)</span><br><span class="line">com = comment.findall(text)</span><br><span class="line"><span class="built_in">print</span>(com)  <span class="comment"># Prints [&#x27; this is a\nmultiline comment &#x27;]</span></span><br></pre></td></tr></table></figure>
<p>在这个模式中，<code>(?:.|\n)</code> 指定了一个非捕获组(也就是它定义了一个仅仅用来做匹配，而不能通过单独捕获或者编号的组)。<br><code>re.compile()</code>函数接受一个标志参数叫 <code>re.DOTALL</code>，在这里非常有用。它可以让正则表达式中的.匹配包括换行符在内的任意字符。比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">comment = re.<span class="built_in">compile</span>(<span class="string">r&#x27;/\*(.*?)\*/&#x27;</span>, re.DOTALL)</span><br><span class="line">com = comment.findall(text)</span><br><span class="line"><span class="built_in">print</span>(com)  <span class="comment"># Prints [&#x27; this is a\nmultiline comment &#x27;]</span></span><br></pre></td></tr></table></figure>
<h4 id="删除字符串中不需要的字符"><a href="#删除字符串中不需要的字符" class="headerlink" title="删除字符串中不需要的字符"></a>删除字符串中不需要的字符</h4><p><code>strip()</code>方法能用于删除开始或结尾的字符。<code>lstrip()</code>和<code>rstrip()</code>分别从左和从右执行删除操作。默认情况下，这些方法会去除空白字符，但是你也可以指定其他字符。<br>如果你想处理中间的空格，那么你需要求助其他技术。比如使用<code>replace()</code>方法或者是用正则表达式替换。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">s = <span class="string">&#x27;Hello        World!&#x27;</span></span><br><span class="line">m = re.sub(<span class="string">&#x27;\s+&#x27;</span>, <span class="string">&#x27; &#x27;</span>, s)</span><br><span class="line"><span class="built_in">print</span>(m) <span class="comment"># Prints Hello World!</span></span><br></pre></td></tr></table></figure>
<h4 id="字符串对齐"><a href="#字符串对齐" class="headerlink" title="字符串对齐"></a>字符串对齐</h4><p>对于基本的字符串对齐操作，可以使用字符串的<code>ljust()</code>,<code>rjust()</code>和<code>center()</code>方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">text = <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line">text = text.ljust(<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(text)  <span class="comment"># Hello World!</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(text))  <span class="comment"># 20</span></span><br><span class="line"></span><br><span class="line">text = <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line">text = text.rjust(<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(text)  <span class="comment">#      Hello World!</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(text))  <span class="comment"># 20</span></span><br></pre></td></tr></table></figure>
<p>所有这些方法都能接受一个可选的填充字符。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">text = <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(text.rjust(<span class="number">20</span>, <span class="string">&#x27;=&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(text.center(<span class="number">20</span>, <span class="string">&#x27;*&#x27;</span>))</span><br><span class="line"><span class="comment"># 当格式化多个值的时候，这些格式代码也可以被用在 format() 方法中</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;:+&gt;10s&#125; &#123;:-&gt;10s&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;World&#x27;</span>)) <span class="comment"># Prints +++++Hello -----World</span></span><br></pre></td></tr></table></figure>
<h4 id="字符串中插入变量"><a href="#字符串中插入变量" class="headerlink" title="字符串中插入变量"></a>字符串中插入变量</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&#x27;&#123;name&#125; has &#123;n&#125; messages.&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s.<span class="built_in">format</span>(name=<span class="string">&#x27;Guido&#x27;</span>, n=<span class="number">37</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果要被替换的变量能在变量域中找到，那么你可以结合使用format_map()和vars() 。就像下面这样：</span></span><br><span class="line">s = <span class="string">&#x27;&#123;name&#125; has &#123;n&#125; messages.&#x27;</span></span><br><span class="line">name = <span class="string">&#x27;Guido&#x27;</span></span><br><span class="line">n = <span class="number">37</span></span><br><span class="line"><span class="built_in">print</span>(s.format_map(<span class="built_in">vars</span>()))</span><br></pre></td></tr></table></figure>
<h4 id="以指定列宽格式化字符串"><a href="#以指定列宽格式化字符串" class="headerlink" title="以指定列宽格式化字符串"></a>以指定列宽格式化字符串</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> textwrap</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(textwrap.fill(s, <span class="number">70</span>))</span><br><span class="line">Look into my eyes, look into my eyes, the eyes, the eyes, the eyes,</span><br><span class="line"><span class="keyword">not</span> around the eyes, don<span class="string">&#x27;t look around the eyes, look into my eyes,</span></span><br><span class="line"><span class="string">you&#x27;</span>re under.</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(textwrap.fill(s, <span class="number">40</span>))</span><br><span class="line">Look into my eyes, look into my eyes,</span><br><span class="line">the eyes, the eyes, the eyes, <span class="keyword">not</span> around</span><br><span class="line">the eyes, don<span class="string">&#x27;t look around the eyes,</span></span><br><span class="line"><span class="string">look into my eyes, you&#x27;</span>re under.</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(textwrap.fill(s, <span class="number">40</span>, initial_indent=<span class="string">&#x27;    &#x27;</span>))</span><br><span class="line">    Look into my eyes, look into my</span><br><span class="line">eyes, the eyes, the eyes, the eyes, <span class="keyword">not</span></span><br><span class="line">around the eyes, don<span class="string">&#x27;t look around the</span></span><br><span class="line"><span class="string">eyes, look into my eyes, you&#x27;</span>re under.</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(textwrap.fill(s, <span class="number">40</span>, subsequent_indent=<span class="string">&#x27;    &#x27;</span>))</span><br><span class="line">Look into my eyes, look into my eyes,</span><br><span class="line">    the eyes, the eyes, the eyes, <span class="keyword">not</span></span><br><span class="line">    around the eyes, don<span class="string">&#x27;t look around</span></span><br><span class="line"><span class="string">    the eyes, look into my eyes, you&#x27;</span>re</span><br><span class="line">    under.</span><br></pre></td></tr></table></figure>
<h4 id="在字符串中处理html和xml"><a href="#在字符串中处理html和xml" class="headerlink" title="在字符串中处理html和xml"></a>在字符串中处理html和xml</h4><p>如果你想替换文本字符串中的<code>‘&lt;’</code>或者<code>‘&gt;’</code>，使用html.escape()函数可以很容易的完成。比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;Elements are written as &quot;&lt;tag&gt;text&lt;/tag&gt;&quot;.&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> html</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s)</span><br><span class="line">Elements are written <span class="keyword">as</span> <span class="string">&quot;&lt;tag&gt;text&lt;/tag&gt;&quot;</span>.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(html.escape(s))</span><br><span class="line">Elements are written <span class="keyword">as</span> <span class="string">&quot;&lt;tag&gt;text&lt;/tag&gt;&quot;</span>.</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Disable escaping of quotes</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(html.escape(s, quote=<span class="literal">False</span>))</span><br><span class="line">Elements are written <span class="keyword">as</span> <span class="string">&quot;&lt;tag&gt;text&lt;/tag&gt;&quot;</span>.</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>如果你接收到了一些含有编码值的原始文本，需要手动去做替换，通常你只需要使用<code>HTML</code>或者<code>XML</code>解析器的一些相关工具函数&#x2F;方法即可。比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;Spicy &quot;Jalapeño&quot;.&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> html.parser <span class="keyword">import</span> HTMLParser</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = HTMLParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.unescape(s)</span><br><span class="line"><span class="string">&#x27;Spicy &quot;Jalapeño&quot;.&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = <span class="string">&#x27;The prompt is &gt;&gt;&gt;&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> xml.sax.saxutils <span class="keyword">import</span> unescape</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>unescape(t)</span><br><span class="line"><span class="string">&#x27;The prompt is &gt;&gt;&gt;&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h4 id="字节字符串上的字符串操作"><a href="#字节字符串上的字符串操作" class="headerlink" title="字节字符串上的字符串操作"></a>字节字符串上的字符串操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = <span class="string">b&#x27;Hello World&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data[<span class="number">0</span>:<span class="number">5</span>]</span><br><span class="line"><span class="string">b&#x27;Hello&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data.startswith(<span class="string">b&#x27;Hello&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data.split()</span><br><span class="line">[<span class="string">b&#x27;Hello&#x27;</span>, <span class="string">b&#x27;World&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data.replace(<span class="string">b&#x27;Hello&#x27;</span>, <span class="string">b&#x27;Hello Cruel&#x27;</span>)</span><br><span class="line"><span class="string">b&#x27;Hello Cruel World&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>这些操作同样也适用于字节数组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = <span class="built_in">bytearray</span>(<span class="string">b&#x27;Hello World&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data[<span class="number">0</span>:<span class="number">5</span>]</span><br><span class="line"><span class="built_in">bytearray</span>(<span class="string">b&#x27;Hello&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data.startswith(<span class="string">b&#x27;Hello&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data.split()</span><br><span class="line">[<span class="built_in">bytearray</span>(<span class="string">b&#x27;Hello&#x27;</span>), <span class="built_in">bytearray</span>(<span class="string">b&#x27;World&#x27;</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data.replace(<span class="string">b&#x27;Hello&#x27;</span>, <span class="string">b&#x27;Hello Cruel&#x27;</span>)</span><br><span class="line"><span class="built_in">bytearray</span>(<span class="string">b&#x27;Hello Cruel World&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>大多数情况下，在文本字符串上的操作均可用于字节字符串。然而，这里也有一些需要注意的不同点。首先，字节字符串的索引操作返回整数而不是单独字符。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">&#x27;Hello World&#x27;</span> <span class="comment"># Text string</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>]</span><br><span class="line"><span class="string">&#x27;H&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;e&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">b&#x27;Hello World&#x27;</span> <span class="comment"># Byte string</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">0</span>]</span><br><span class="line"><span class="number">72</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">1</span>]</span><br><span class="line"><span class="number">101</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>第二点，字节字符串不会提供一个美观的字符串表示，也不能很好的打印出来，除非它们先被解码为一个文本字符串。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">b&#x27;Hello World&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s)</span><br><span class="line"><span class="string">b&#x27;Hello World&#x27;</span> <span class="comment"># Observe b&#x27;...&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s.decode(<span class="string">&#x27;ascii&#x27;</span>))</span><br><span class="line">Hello World</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>参考文献</strong><br>[1] <a target="_blank" rel="noopener" href="https://www.gitbook.com/book/lenkimo/byte-of-python-chinese-edition/details">A Byte of Python3</a><br>[2] <a target="_blank" rel="noopener" href="http://python3-cookbook.readthedocs.org/zh_CN/latest/c01/p08_calculating_with_dict.html">python3-cookbook</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.sovdating.com/CentOS-7-1-switch-in-command-line-mode-and-desktop-mode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DJY">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sovdating Linux">
      <meta itemprop="description" content="Hello dev">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sovdating Linux">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/CentOS-7-1-switch-in-command-line-mode-and-desktop-mode/" class="post-title-link" itemprop="url">CentOS 7.1 切换命令行模式与桌面模式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2015-06-22 19:37:06" itemprop="dateCreated datePublished" datetime="2015-06-22T19:37:06+08:00">2015-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-01-24 10:24:42" itemprop="dateModified" datetime="2024-01-24T10:24:42+08:00">2024-01-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Operating-System/" itemprop="url" rel="index"><span itemprop="name">Operating System</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>首先你需要知道自己的Linux版本信息，下面介绍一些常用的查看Linux系统版本的命令</p>
<ol>
<li>查看内核版本命令，以下三个命令任选<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@localhost ~]$ <span class="built_in">cat</span> /proc/version</span><br><span class="line">Linux version 3.10.0-229.el7.x86_64 (builder@kbuilder.dev.centos.org) (gcc version 4.8.2 20140120 (Red Hat 4.8.2-16) (GCC) ) <span class="comment">#1 SMP Fri Mar 6 11:36:42 UTC 2015</span></span><br><span class="line"></span><br><span class="line">[hadoop@localhost ~]$ <span class="built_in">uname</span> -a</span><br><span class="line">Linux localhost.localdomain 3.10.0-229.el7.x86_64 <span class="comment">#1 SMP Fri Mar 6 11:36:42 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux</span></span><br><span class="line"></span><br><span class="line">[hadoop@localhost ~]$ <span class="built_in">uname</span> -r</span><br><span class="line">3.10.0-229.el7.x86_64</span><br></pre></td></tr></table></figure></li>
<li>查看linux版本<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@localhost ~]$ <span class="built_in">cat</span> /etc/redhat-release </span><br><span class="line">CentOS Linux release 7.1.1503 (Core) </span><br></pre></td></tr></table></figure></li>
</ol>
<p>那么知道了版本之后如何修改默认启动时进入命令行还是桌面环境呢？在<code>CentOS7.x</code>之前的版本都是通过修改<code>/etc/inittab</code>文件来设置启动顺序，具体可参考<a target="_blank" rel="noopener" href="http://www.habadog.com/2012/03/03/centos-model-switch/">这里</a>。但是此种方法并不适应于<code>CentOS7.x</code>版本，在该版本中，我们查看<code>/etc/inittab</code>文件可得</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@localhost ~]$ vim /etc/inittab</span><br><span class="line"><span class="comment"># inittab is no longer used when using systemd.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ADDING CONFIGURATION HERE WILL HAVE NO EFFECT ON YOUR SYSTEM.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Ctrl-Alt-Delete is handled by /usr/lib/systemd/system/ctrl-alt-del.target</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># systemd uses &#x27;targets&#x27; instead of runlevels. By default, there are two main targets:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># multi-user.target: analogous to runlevel 3</span></span><br><span class="line"><span class="comment"># graphical.target: analogous to runlevel 5</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># To view current default target, run:</span></span><br><span class="line"><span class="comment"># systemctl get-default</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># To set a default target, run:</span></span><br><span class="line"><span class="comment"># systemctl set-default TARGET.target</span></span><br></pre></td></tr></table></figure>
<p>该文件中已经详细说明了，不再使用inittab文件而是使用systemd代替，并且还指出，现在只有<code>multi-user</code>相当于运行级别是3和<code>graphical</code>相当于运行级别是5，现在可以使用如下命令设置默认启动级别了，注意要以root用户，或者是使用sudo权限</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost hadoop]<span class="comment"># systemctl set-default multi-user.target</span></span><br><span class="line"><span class="built_in">rm</span> <span class="string">&#x27;/etc/systemd/system/default.target&#x27;</span></span><br><span class="line"><span class="built_in">ln</span> -s <span class="string">&#x27;/usr/lib/systemd/system/multi-user.target&#x27;</span> <span class="string">&#x27;/etc/systemd/system/default.target&#x27;</span></span><br><span class="line">[root@localhost hadoop]<span class="comment"># </span></span><br></pre></td></tr></table></figure>
<p>设置成功之后reboot一下，即可顺利进入命令行界面了，如果想要再次进入图形界面，在命令行中运行<code>startx</code>即可。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.sovdating.com/Basic-knowledge-summary-of-Spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DJY">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sovdating Linux">
      <meta itemprop="description" content="Hello dev">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sovdating Linux">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/Basic-knowledge-summary-of-Spring/" class="post-title-link" itemprop="url">Spring基础知识汇总</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2015-06-21 11:57:22" itemprop="dateCreated datePublished" datetime="2015-06-21T11:57:22+08:00">2015-06-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-01-24 10:24:42" itemprop="dateModified" datetime="2024-01-24T10:24:42+08:00">2024-01-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming-Notes/" itemprop="url" rel="index"><span itemprop="name">Programming Notes</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/shijiebei2009/img/master/blog/spring_logo.png" title="logo"><img src="https://raw.githubusercontent.com/shijiebei2009/img/master/blog/spring_logo.png" alt="logo" title="logo"></a></p>
<h3 id="Spring简介"><a href="#Spring简介" class="headerlink" title="Spring简介"></a>Spring简介</h3><p>Spring框架由Rod Johnson开发，<a target="_blank" rel="noopener" href="https://twitter.com/springrod">Rod Johnson’s twitter</a>，<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/2192255.htm">Rod Johnson’s 百度百科</a>，2004年发布了Spring框架的第一版。Spring是一个从实际开发中抽取出来的框架，因此它完成了大量开发中的通用步骤，留给开发者的仅仅是与特定应用相关的部分，从而大大提高了企业应用的开发效率。</p>
<p>Spring总结起来优点如下</p>
<ul>
<li>低侵入式设计，代码的污染极低</li>
<li>独立于各种应用服务器，基于Spring框架的应用，可以真正实现Write Once，Run Anywhere的承诺</li>
<li>Spring的IoC容器降低了业务对象替换的复杂性，提高了组件之间的解耦</li>
<li>Spring的AOP支持允许将一些通用任务如安全、事务、日志等进行集中式管理，从而提供了更好的复用</li>
<li>Spring的ORM和DAO提供了与第三方持久层框架的良好整合，并简化了底层的数据库访问</li>
<li>Spring的高度开放性，并不强制应用完全依赖于Spring，开发者可自由选用Spring框架的部分或全部</li>
</ul>
<p>Spring框架的组成结构图如下所示<br><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/shijiebei2009/img/master/blog/spring_overview_architecture.png" title="spring-overview"><img src="https://raw.githubusercontent.com/shijiebei2009/img/master/blog/spring_overview_architecture.png" alt="spring-overview" title="spring-overview"></a></p>
<h3 id="Spring的核心机制"><a href="#Spring的核心机制" class="headerlink" title="Spring的核心机制"></a>Spring的核心机制</h3><h4 id="管理Bean"><a href="#管理Bean" class="headerlink" title="管理Bean"></a>管理Bean</h4><p>程序主要是通过Spring容器来访问容器中的Bean，ApplicationContext是Spring容器最常用的接口，该接口有如下两个实现类</p>
<ul>
<li>ClassPathXmlApplicationContext: 从类加载路径下搜索配置文件，并根据配置文件来创建Spring容器</li>
<li>FileSystemXmlApplicationContext: 从文件系统的相对路径或绝对路径下去搜索配置文件，并根据配置文件来创建Spring容器</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> ctx.getBean(<span class="string">&quot;person&quot;</span>, Person.class);</span><br><span class="line">        p.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Eclipse使用Spring"><a href="#Eclipse使用Spring" class="headerlink" title="Eclipse使用Spring"></a>Eclipse使用Spring</h4><p>在Eclipse等IDE工具中，用户可以自建<code>User Library</code>，然后把Spring的Jar包都放入其中，当然也可以将Jar包直接放在项目的<code>/WEB-INF/lib</code>目录下，但是如果使用<code>User Library</code>，在项目发布时，需要将用户库所引用的Jar文件随应用一起发布，就是将User Library所使用的Jar复制到<code>/WEB-INF/lib</code>目录下，这是因为对于一个Web应用，Eclipse部署Web应用时不会将用户库的Jar文件复制到<code>/WEB-INF/lib</code>下，需要手动复制。</p>
<h4 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h4><p>Spring框架的核心功能有两个</p>
<ul>
<li>Spring容器作为超级大工厂，负责创建、管理所有的Java对象，这些Java对象被称为Bean</li>
<li>Spring容器管理容器中Bean之间的依赖关系，Spring使用一种被称为“依赖注入”的方式来管理Bean之间的依赖关系</li>
</ul>
<p>使用依赖注入，不仅可以为Bean注入普通的属性值，还可以注入其他Bean的引用。依赖注入是一种优秀的解耦方式，其可以让Bean以配置文件组织在一起，而不是以硬编码的方式耦合在一起。</p>
<h5 id="理解依赖注入"><a href="#理解依赖注入" class="headerlink" title="理解依赖注入"></a>理解依赖注入</h5><p>Rod Johnson是第一个高度重视以配置文件来管理Java实例的协作关系的人，他给这种方式起了一个名字：控制反转（Inverse of Control，IoC）。后来Martine Fowler为这种方式起了另一个名称：依赖注入（Dependency Injection），因此不管是依赖注入，还是控制反转，其含义完全相同。当某个Java对象（调用者）需要调用另一个Java对象（被依赖对象）的方法时，在传统模式下通常有两种做法</p>
<ol>
<li>原始做法: 调用者<strong>主动</strong>创建被依赖对象，然后再调用被依赖对象的方法</li>
<li>简单工厂模式: 调用者先找到被依赖对象的工厂，然后<strong>主动</strong>通过工厂去获取被依赖对象，最后再调用被依赖对象的方法</li>
</ol>
<p>注意上面的<strong>主动</strong>二字，这必然会导致调用者与被依赖对象实现类的硬编码耦合，非常不利于项目升级的维护。使用Spring框架之后，调用者无需<strong>主动</strong>获取被依赖对象，调用者只要<strong>被动</strong>接受Spring容器为调用者的成员变量赋值即可，由此可见，使用Spring后，调用者获取被依赖对象的方式由原来的主动获取，变成了被动接受——所以Rod Johnson称之为控制反转。</p>
<p>另外从Spring容器的角度来看，Spring容器负责将被依赖对象赋值给调用者的成员变量——相当于为调用者注入它依赖的实例，因此Martine Fowler称之为依赖注入。</p>
<h5 id="设值注入"><a href="#设值注入" class="headerlink" title="设值注入"></a>设值注入</h5><p>设值注入是指IoC容器通过成员变量的setter方法来注入被依赖对象。这种注入方式简单、直观，因而在Spring的依赖注入里大量使用。</p>
<h5 id="构造注入"><a href="#构造注入" class="headerlink" title="构造注入"></a>构造注入</h5><p>利用构造器来设置依赖关系的方式，被称为构造注入。通俗来说，就是驱动Spring在底层以反射方式执行带指定参数的构造器，当执行带参数的构造器时，就可利用构造器参数对成员变量执行初始化——这就是构造注入的本质。</p>
<h5 id="两种注入方式的对比"><a href="#两种注入方式的对比" class="headerlink" title="两种注入方式的对比"></a>两种注入方式的对比</h5><p>设值注入有如下优点</p>
<ul>
<li>与传统的JavaBean的写法更相似，程序开发人员更容易理解、接受。通过setter方法设定依赖关系显得更加直观、自然</li>
<li>对于复杂的依赖关系，如果采用构造注入，会导致构造器过于臃肿，难以阅读。Spring在创建Bean实例时，需要同时实例化其依赖的全部实例，因而导致性能下降。而使用设值注入，则能避免这些问题。</li>
<li>尤其在某些成员变量可选的情况下，多参数的构造器更加笨重</li>
</ul>
<p>构造注入优势如下</p>
<ul>
<li>构造注入可以在构造器中决定依赖关系的注入顺序，优先依赖的优先注入</li>
<li>对于依赖关系无需变化的Bean，构造注入更有用处。因为没有setter方法，所有的依赖关系全部在构造器内设定，无须担心后续的代码对依赖关系产生破坏</li>
<li>依赖关系只能在构造器中设定，则只有组件的创建者才能改变组件的依赖关系，对组件的调用者而言，组件内部的依赖关系完全透明，更符合高内聚的原则</li>
</ul>
<p><em><strong>Notes</strong></em><br>建议采用设值注入为主，构造注入为辅的注入策略。对于依赖关系无须变化的注入，尽量采用构造注入；而其他依赖关系的注入，则考虑采用设值注入。</p>
<h4 id="Spring容器中的Bean"><a href="#Spring容器中的Bean" class="headerlink" title="Spring容器中的Bean"></a>Spring容器中的Bean</h4><p>对于开发者来说，开发者使用Spring框架主要是做两件事：①开发Bean；②配置Bean。对于Spring框架来说，它要做的就是根据配置文件来创建Bean实例，并调用Bean实例的方法完成“依赖注入”——这就是所谓IoC的本质。</p>
<h5 id="容器中Bean的作用域"><a href="#容器中Bean的作用域" class="headerlink" title="容器中Bean的作用域"></a>容器中Bean的作用域</h5><p>当通过Spring容器创建一个Bean实例时，不仅可以完成Bean实例的实例化，还可以为Bean指定特定的作用域。Spring支持如下五种作用域</p>
<ol>
<li>singleton: 单例模式，在整个Spring IoC容器中，singleton作用域的Bean将只生成一个实例</li>
<li>prototype: 每次通过容器的getBean()方法获取prototype作用域的Bean时，都将产生一个新的Bean实例</li>
<li>request: 对于一次HTTP请求，request作用域的Bean将只生成一个实例，这意味着，在同一次HTTP请求内，程序每次请求该Bean，得到的总是同一个实例。只有在Web应用中使用Spring时，该作用域才真正有效</li>
<li>对于一次HTTP会话，session作用域的Bean将只生成一个实例，这意味着，在同一次HTTP会话内，程序每次请求该Bean，得到的总是同一个实例。只有在Web应用中使用Spring时，该作用域才真正有效</li>
<li>global session: 每个全局的HTTP Session对应一个Bean实例。在典型的情况下，仅在使用portlet context的时候有效，同样只在Web应用中有效</li>
</ol>
<p>如果不指定Bean的作用域，Spring默认使用singleton作用域。prototype作用域的Bean的创建、销毁代价比较大。而singleton作用域的Bean实例一旦创建成果，就可以重复使用。因此，应该尽量避免将Bean设置成prototype作用域。</p>
<h4 id="使用自动装配注入合作者Bean"><a href="#使用自动装配注入合作者Bean" class="headerlink" title="使用自动装配注入合作者Bean"></a>使用自动装配注入合作者Bean</h4><p>Spring能自动装配Bean与Bean之间的依赖关系，即无须使用ref显式指定依赖Bean，而是由Spring容器检查XML配置文件内容，根据某种规则，为调用者Bean注入被依赖的Bean。<br>Spring自动装配可通过<code>&lt;beans/&gt;</code>元素的<code>default-autowire</code>属性指定，该属性对配置文件中所有的Bean起作用；也可通过对<code>&lt;bean/&gt;</code>元素的<code>autowire</code>属性指定，该属性只对该Bean起作用。</p>
<p><code>autowire</code>和<code>default-autowire</code>可以接受如下值</p>
<ul>
<li><code>no</code>: 不使用自动装配。Bean依赖必须通过ref元素定义。这是默认配置，在较大的部署环境中不鼓励改变这个配置，显式配置合作者能够得到更清晰的依赖关系</li>
<li><code>byName</code>: 根据setter方法名进行自动装配。Spring容器查找容器中全部Bean，找出其id与setter方法名去掉set前缀，并小写首字母后同名的Bean来完成注入。如果没有找到匹配的Bean实例，则Spring不会进行任何注入</li>
<li><code>byType</code>: 根据setter方法的形参类型来自动装配。Spring容器查找容器中的全部Bean，如果正好有一个Bean类型与setter方法的形参类型匹配，就自动注入这个Bean；如果找到多个这样的Bean，就抛出一个异常；如果没有找到这样的Bean，则什么都不会发生，setter方法不会被调用</li>
<li><code>constructor</code>: 与byType类似，区别是用于自动匹配构造器的参数。如果容器不能恰好找到一个与构造器参数类型匹配的Bean，则会抛出一个异常</li>
<li><code>autodetect</code>: Spring容器根据Bean内部结构，自行决定使用constructor或byType策略。如果找到一个默认的构造函数，那么就会应用byType策略</li>
</ul>
<p><em><strong>当一个Bean既使用自动装配依赖，又使用ref显式指定依赖时，则显式指定的依赖覆盖自动装配依赖；对于大型的应用，不鼓励使用自动装配。虽然使用自动装配可减少配置文件的工作量，但大大将死了依赖关系的清晰性和透明性。依赖关系的装配依赖于源文件的属性名和属性类型，导致Bean与Bean之间的耦合降低到代码层次，不利于高层次解耦</strong></em></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--通过设置可以将Bean排除在自动装配之外--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">autowire-candidate</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--除此之外，还可以在beans元素中指定，支持模式字符串，如下所有以abc结尾的Bean都被排除在自动装配之外--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">default-autowire-candidates</span>=<span class="string">&quot;*abc&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="创建Bean的3种方式"><a href="#创建Bean的3种方式" class="headerlink" title="创建Bean的3种方式"></a>创建Bean的3种方式</h3><h4 id="使用构造器创建Bean实例"><a href="#使用构造器创建Bean实例" class="headerlink" title="使用构造器创建Bean实例"></a>使用构造器创建Bean实例</h4><p>使用构造器来创建Bean实例是最常见的情况，如果不采用构造注入，Spring底层会调用Bean类的无参数构造器来创建实例，因此要求该Bean类提供无参数的构造器。</p>
<p>采用默认的构造器创建Bean实例，Spring对Bean实例的所有属性执行默认初始化，即所有的基本类型的值初始化为0或false；所有的引用类型的值初始化为null。</p>
<h4 id="使用静态工厂方法创建Bean"><a href="#使用静态工厂方法创建Bean" class="headerlink" title="使用静态工厂方法创建Bean"></a>使用静态工厂方法创建Bean</h4><p>使用静态工厂方法创建Bean实例时，class属性也必须指定，但此时class属性并不是指定Bean实例的实现类，而是静态工厂类，Spring通过该属性知道由哪个工厂类来创建Bean实例。</p>
<p>除此之外，还需要使用factory-method属性来指定静态工厂方法，Spring将调用静态工厂方法返回一个Bean实例，一旦获得了指定Bean实例，Spring后面的处理步骤与采用普通方法创建Bean实例完全一样。如果静态工厂方法需要参数，则使用<code>&lt;constructor-arg.../&gt;</code>元素指定静态工厂方法的参数。</p>
<h4 id="调用实例工厂方法创建Bean"><a href="#调用实例工厂方法创建Bean" class="headerlink" title="调用实例工厂方法创建Bean"></a>调用实例工厂方法创建Bean</h4><p>实例工厂方法与静态工厂方法只有一个不同：调用静态工厂方法只需使用工厂类即可，而调用实例工厂方法则需要工厂实例。使用实例工厂方法时，配置Bean实例的<code>&lt;bean.../&gt;</code>元素无须class属性，配置实例工厂方法使用<code>factory-bean</code>指定工厂实例。<br>采用实例工厂方法创建Bean的<code>&lt;bean.../&gt;</code>元素时需要指定如下两个属性</p>
<ul>
<li>factory-bean: 该属性的值为工厂Bean的id</li>
<li>factory-method: 该属性指定实例工厂的工厂方法</li>
</ul>
<p>若调用实例工厂方法时需要传入参数，则使用<code>&lt;constructor-arg.../&gt;</code>元素确定参数值。</p>
<h3 id="协调作用域不同步的Bean"><a href="#协调作用域不同步的Bean" class="headerlink" title="协调作用域不同步的Bean"></a>协调作用域不同步的Bean</h3><p>当singleton作用域的Bean依赖于prototype作用域的Bean时，会产生不同步的现象，原因是因为当Spring容器初始化时，容器会预初始化容器中所有的<code>singleton Bean</code>，由于<code>singleton Bean</code>依赖于<code>prototype Bean</code>，因此Spring在初始化<code>singleton Bean</code>之前，会先创建<code>prototypeBean</code>——然后才创建<code>singleton Bean</code>，接下里将<code>prototype Bean</code>注入<code>singleton Bean</code>。<br>解决不同步的方法有两种</p>
<ul>
<li>放弃依赖注入: singleton作用域的Bean每次需要prototype作用域的Bean时，主动向容器请求新的Bean实例，即可保证每次注入的<code>prototype Bean</code>实例都是最新的实例</li>
<li>利用方法注入: 方法注入通常使用lookup方法注入，使用lookup方法注入可以让Spring容器重写容器中Bean的抽象或具体方法，返回查找容器中其他Bean的结果，被查找的Bean通常是一个<code>non-singleton Bean</code>。Spring通过使用JDK动态代理或cglib库修改客户端的二进制码，从而实现上述要求</li>
</ul>
<p>建议采用第二种方法，使用方法注入。为了使用lookup方法注入，大致需要如下两步</p>
<ol>
<li>将调用者Bean的实现类定义为抽象类，并定义一个抽象方法来获取被依赖的Bean</li>
<li>在<code>&lt;bean.../&gt;</code>元素中添加<code>&lt;lookup-method.../&gt;</code>子元素让Spring为调用者Bean的实现类实现指定的抽象方法</li>
</ol>
<p><em><strong>Notes</strong></em></p>
<blockquote>
<p>Spring会采用运行时动态增强的方式来实现<code>&lt;lookup-method.../&gt;</code>元素所指定的抽象方法，如果目标抽象类实现过接口，Spring会采用JDK动态代理来实现该抽象类，并为之实现抽象方法；如果目标抽象类没有实现过接口，Spring会采用cglib实现该抽象类，并为之实现抽象方法。Spring4.0的spring-core-xxx.jar包中已经集成了cglib类库。</p>
</blockquote>
<h3 id="两种后处理器"><a href="#两种后处理器" class="headerlink" title="两种后处理器"></a>两种后处理器</h3><p>Spring提供了两种常用的后处理器</p>
<ul>
<li>Bean后处理器: 这种后处理器会对容器中Bean进行后处理，对Bean进行额外加强</li>
<li>容器后处理器: 这种后处理器会对IoC容器进行后处理，用于增强容器功能</li>
</ul>
<h4 id="Bean后处理器"><a href="#Bean后处理器" class="headerlink" title="Bean后处理器"></a>Bean后处理器</h4><p>Bean后处理器是一种特殊的Bean，这种特殊的Bean并不对外提供服务，它甚至可以无须id属性，它主要负责对容器中的其他Bean执行后处理，例如为容器中的目标Bean生成代理等，这种Bean称为Bean后处理器。Bean后处理器会在Bean实例创建成功之后，对Bean实例进行进一步的增强处理。Bean后处理器必须实现<code>BeanPostProcessor</code>接口，同时必须实现该接口的两个方法。</p>
<ol>
<li><code>Object postProcessBeforeInitialization(Object bean, String name) throws BeansException</code>: 该方法的第一个参数是系统即将进行后处理的Bean实例，第二个参数是该Bean的配置id</li>
<li><code>Object postProcessAfterinitialization(Object bean, String name) throws BeansException</code>: 该方法的第一个参数是系统即将进行后处理的Bean实例，第二个参数是该Bean的配置id</li>
</ol>
<p>容器中一旦注册了Bean后处理器，Bean后处理器就会自动启动，在容器中每个Bean创建时自动工作，Bean后处理器两个方法的回调时机如下图<br><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/shijiebei2009/img/master/blog/spring_bean_post_process.jpg" title="bean-post-process"><img src="https://raw.githubusercontent.com/shijiebei2009/img/master/blog/spring_bean_post_process.jpg" alt="bean-post-process" title="bean-post-process"></a></p>
<p>注意一点，如果使用<code>BeanFactory</code>作为Spring容器，则必须手动注册Bean后处理器，程序必须获取Bean后处理器实例，然后手动注册。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BeanPostProcessor</span> <span class="variable">bp</span> <span class="operator">=</span> (BeanPostProcessor)beanFactory.getBean(<span class="string">&quot;bp&quot;</span>);</span><br><span class="line">beanFactory.addBeanPostProcessor(bp);</span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person)beanFactory.getBean(<span class="string">&quot;person&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="容器后处理器"><a href="#容器后处理器" class="headerlink" title="容器后处理器"></a>容器后处理器</h4><p>Bean后处理器负责处理容器中的所有Bean实例，而容器后处理器则负责处理容器本身。容器后处理器必须实现<code>BeanFactoryPostProcessor</code>接口，并实现该接口的一个方法<code>postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)</code>实现该方法的方法体就是对Spring容器进行的处理，这种处理可以对Spring容器进行自定义扩展，当然也可以对Spring容器不进行任何处理。</p>
<p>类似于<code>BeanPostProcessor</code>，<code>ApplicationContext</code>可自动检测到容器中的容器后处理器，并且自动注册容器后处理器。但若使用<code>BeanFactory</code>作为Spring容器，则必须手动调用该容器后处理器来处理<code>BeanFactory</code>容器。</p>
<h3 id="Spring的“零配置”支持"><a href="#Spring的“零配置”支持" class="headerlink" title="Spring的“零配置”支持"></a>Spring的“零配置”支持</h3><h4 id="搜索Bean类"><a href="#搜索Bean类" class="headerlink" title="搜索Bean类"></a>搜索Bean类</h4><p>Spring提供如下几个Annotation来标注Spring Bean</p>
<ul>
<li><code>@Component</code>: 标注一个普通的Spring Bean类</li>
<li><code>@Controller</code>: 标注一个控制器组件类</li>
<li><code>@Service</code>: 标注一个业务逻辑组件类</li>
<li><code>@Repository</code>: 标注一个DAO组件类</li>
</ul>
<p>在Spring配置文件中做如下配置，指定自动扫描的包</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;edu.shu.spring.domain&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="使用-Resource配置依赖"><a href="#使用-Resource配置依赖" class="headerlink" title="使用@Resource配置依赖"></a>使用@Resource配置依赖</h4><p><code>@Resource</code>位于<code>javax.annotation</code>包下，是来自JavaEE规范的一个<code>Annotation</code>，Spring直接借鉴了该<code>Annotation</code>，通过使用该<code>Annotation</code>为目标Bean指定协作者Bean。使用<code>@Resource</code>与<code>&lt;property.../&gt;</code>元素的ref属性有相同的效果。<br><code>@Resource</code>不仅可以修饰setter方法，也可以直接修饰实例变量，如果使用<code>@Resource</code>修饰实例变量将会更加简单，此时Spring将会直接使用JavaEE规范的Field注入，此时连setter方法都可以不要。</p>
<h4 id="使用-PostConstruct和-PreDestroy定制生命周期行为"><a href="#使用-PostConstruct和-PreDestroy定制生命周期行为" class="headerlink" title="使用@PostConstruct和@PreDestroy定制生命周期行为"></a>使用@PostConstruct和@PreDestroy定制生命周期行为</h4><p><code>@PostConstruct</code>和<code>@PreDestroy</code>同样位于javax.annotation包下，也是来自JavaEE规范的两个Annotation，Spring直接借鉴了它们，用于定制Spring容器中Bean的生命周期行为。它们都用于修饰方法，无须任何属性。其中前者修饰的方法时Bean的初始化方法；而后者修饰的方法时Bean销毁之前的方法。</p>
<h4 id="Spring4-0增强的自动装配和精确装配"><a href="#Spring4-0增强的自动装配和精确装配" class="headerlink" title="Spring4.0增强的自动装配和精确装配"></a>Spring4.0增强的自动装配和精确装配</h4><p>Spring提供了<code>@Autowired</code>注解来指定自动装配，<code>@Autowired</code>可以修饰setter方法、普通方法、实例变量和构造器等。当使用<code>@Autowired</code>标注setter方法时，默认采用byType自动装配策略。在这种策略下，符合自动装配类型的候选Bean实例常常有多个，这个时候就可能引起异常，为了实现精确的自动装配，Spring提供了<code>@Qualifier</code>注解，通过使用<code>@Qualifier</code>，允许根据Bean的id来执行自动装配。</p>
<h3 id="Spring的AOP"><a href="#Spring的AOP" class="headerlink" title="Spring的AOP"></a>Spring的AOP</h3><h4 id="为什么需要AOP"><a href="#为什么需要AOP" class="headerlink" title="为什么需要AOP"></a>为什么需要AOP</h4><p>AOP（Aspect Orient Programming）也就是面向切面编程，作为面向对象编程的一种补充，已经成为一种比较成熟的编程方式。其实AOP问世的时间并不太长，AOP和OOP互为补充，面向切面编程将程序运行过程分解成各个切面。</p>
<p>AOP专门用于处理系统中分布于各个模块（不同方法）中的交叉关注点的问题，在JavaEE应用中，常常通过AOP来处理一些具有横切性质的系统级服务，如事务管理、安全检查、缓存、对象池管理等，AOP已经成为一种非常常用的解决方案。</p>
<h4 id="使用AspectJ实现AOP"><a href="#使用AspectJ实现AOP" class="headerlink" title="使用AspectJ实现AOP"></a>使用AspectJ实现AOP</h4><p>AspectJ是一个基于Java语言的AOP框架，提供了强大的AOP功能，其他很多AOP框架都借鉴或采纳其中的一些思想。其主要包括两个部分：一个部分定义了如何表达、定义AOP编程中的语法规范，通过这套语法规范，可以方便地用AOP来解决Java语言中存在的交叉关注点的问题；另一个部分是工具部分，包括编译、调试工具等。</p>
<p>AOP实现可分为两类</p>
<ol>
<li>静态AOP实现: AOP框架在编译阶段对程序进行修改，即实现对目标类的增强，生成静态的AOP代理类，以AspectJ为代表</li>
<li>动态AOP实现: AOP框架在运行阶段动态生成AOP代理，以实现对目标对象的增强，以Spring AOP为代表</li>
</ol>
<p>一般来说，静态AOP实现具有较好的性能，但需要使用特殊的编译器。动态AOP实现是纯Java实现，因此无须特殊的编译器，但是通常性能略差。</p>
<h4 id="AOP的基本概念"><a href="#AOP的基本概念" class="headerlink" title="AOP的基本概念"></a>AOP的基本概念</h4><p>关于面向切面编程的一些术语</p>
<ul>
<li>切面（Aspect）: 切面用于组织多个Advice，Advice放在切面中定义</li>
<li>连接点（Joinpoint）: 程序执行过程中明确的点，如方法的调用，或者异常的抛出。在Spring AOP中，连接点总是方法的调用</li>
<li>增强处理（Advice）: AOP框架在特定的切入点执行的增强处理。处理有“around”、“before”和“after”等类型</li>
<li>切入点（Pointcut）: 可以插入增强处理的连接点。简而言之，当某个连接点满足指定要求时，该连接点将被添加增强处理，该连接点也就变成了切入点</li>
</ul>
<h4 id="Spring的AOP支持"><a href="#Spring的AOP支持" class="headerlink" title="Spring的AOP支持"></a>Spring的AOP支持</h4><p>Spring中的AOP代理由Spring的IoC容器负责生成、管理，其依赖关系也由IoC容器负责管理。<br>为了在应用中使用<code>@AspectJ</code>支持，Spring需要添加三个库</p>
<ul>
<li><code>aspectjweaver.jar</code></li>
<li><code>aspectjrt.jar</code></li>
<li><code>aopalliance.jar</code></li>
</ul>
<p>并在Spring配置文件中做如下配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--启动@AspectJ支持--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--指定自动搜索Bean组件、自动搜索切面类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;edu.shu.sprint.service&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.aspectj.lang.annotation.Aspect&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>参考文献</strong><br>[1] 轻量级JavaEE企业应用实战-Struts2+Spring4+Hibernate整合开发</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.sovdating.com/Basic-knowledge-summary-of-Hibernate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DJY">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sovdating Linux">
      <meta itemprop="description" content="Hello dev">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sovdating Linux">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/Basic-knowledge-summary-of-Hibernate/" class="post-title-link" itemprop="url">Hibernate基础知识汇总</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2015-06-19 18:59:12" itemprop="dateCreated datePublished" datetime="2015-06-19T18:59:12+08:00">2015-06-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-01-24 10:24:42" itemprop="dateModified" datetime="2024-01-24T10:24:42+08:00">2024-01-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming-Notes/" itemprop="url" rel="index"><span itemprop="name">Programming Notes</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/shijiebei2009/img/master/blog/hibernate_logo.gif" title="logo"><img src="https://raw.githubusercontent.com/shijiebei2009/img/master/blog/hibernate_logo.gif" alt="logo" title="logo"></a></p>
<h3 id="ORM简介"><a href="#ORM简介" class="headerlink" title="ORM简介"></a>ORM简介</h3><p>ORM（Object&#x2F;Relation Mapping），对象关系映射，ORM是一种规范，主要完成面向对象的编程语言到关系数据库的映射。<br>ORM框架是面向对象程序设计语言与关系数据库发展不同步时的中间解决方案。ORM工具的唯一作用就是：把对持久化对象的保存、删除、修改等操作，转换成对数据库的操作，从此，就可以以面向对象的方式操作持久化对象，而ORM框架则负责转换成对应的SQL操作。</p>
<h3 id="数据源简介"><a href="#数据源简介" class="headerlink" title="数据源简介"></a>数据源简介</h3><p>数据源是一种提高数据库连接性能的常规手段，数据源会负责维持一个数据连接池，当程序创建数据源实例时，系统会一次性地创建多个数据库连接，并把这些数据库连接保存在连接池中。当程序需要进行数据库访问时，无需重新获得数据库连接，而是从连接池中取出一个空闲的数据库连接。当程序使用数据库连接访问数据库结束后，无需关闭数据库连接，而是将数据库连接归还给连接池即可。通过此种方式，可以避免频繁地获取数据库连接、关闭数据库连接所导致的性能下降。</p>
<h3 id="Hibernate体系结构"><a href="#Hibernate体系结构" class="headerlink" title="Hibernate体系结构"></a>Hibernate体系结构</h3><p><strong>Hibernate的体系架构如下所示</strong></p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/shijiebei2009/img/master/blog/hibernate_architecture.png" title="architecture"><img src="https://raw.githubusercontent.com/shijiebei2009/img/master/blog/hibernate_architecture.png" alt="architecture" title="architecture"></a></p>
<p>下面对上图中各对象逐一解释</p>
<ul>
<li>SessionFactory: 这是Hibernate的关键对象，它是单个数据库映射关系经过编译后的内存镜像，也是线程安全的。它是生成Session的工厂，本身需要依赖于ConnectionProvider。该对象可以在进程或集群的级别上，为那些事务之间可以重用的数据提供可选的二级缓存</li>
<li>Session: 它是应用程序与持久存储层直接交互的一个单线程对象。它也是Hibernate持久化操作的管家对象，所有的持久化对象必须在Session管理下才可以进行持久化操作。此对象生存期很短。它底层封装了JDBC连接，它也是Transaction的工厂 。Session对象持有必选的一级缓存，在显式执行flush之前，所有持久化操作的数据都在缓存中的Session对象处</li>
<li>PO（Persistent Object）: 系统创建的POJO实例，一旦与特定的Session关联，并对应数据表的指定记录，该对象就处于持久化状态，这一系列对象都被称为持久化对象。在程序中对持久化对象执行的修改，都将自动被转换为对持久层的修改。持久化对象完全可以是普通的JavaBeans&#x2F;POJO，唯一的区别是它们正与一个Session关联</li>
<li>瞬态对象和脱管对象: 系统通过new关键字创建的Java实例，没有与Session关联，此时处于瞬态。瞬态实例可能是被应用程序实例化后，尚未进行持久化的对象。如果一个曾经持久化过的实例，如果Session被关闭则转为脱管状态</li>
<li>事务（Transaction）: 代表一次原子操作，它具有数据库事务的概念。Hibernate事务是对底层具体的JDBC、JTA以及CORBA事务的抽象。在某些情况下，一个Session之间可能包含多个Transaction对象。虽然事务操作是可选的，但所有持久化操作都应该在事务管理下进行，即使是只读操作</li>
<li>连接提供者（ConnectionProvider）: 它是生成JDBC连接的工厂，它通过抽象将应用程序与底层DataSource或DriverManager隔离开。这个对象无需应用程序直接访问，仅在应用程序需要扩展时使用</li>
<li>事务工厂（TransactionFactory）: 它是生成Transaction对象实例的工厂。该对象也无需应用程序直接访问。它负责对底层具体的事务实现进行封装，将底层具体的事务抽象成Hibernate事务</li>
</ul>
<h3 id="深入理解持久化对象"><a href="#深入理解持久化对象" class="headerlink" title="深入理解持久化对象"></a>深入理解持久化对象</h3><h4 id="持久化类的要求"><a href="#持久化类的要求" class="headerlink" title="持久化类的要求"></a>持久化类的要求</h4><ul>
<li>提供一个无参数的构造器: 所有的持久化类都应该提供一个无参数的构造器，这个构造器可以不采用public访问控制符。只要提供了无参数的构造器，Hibernate就可以使用Constructor.newInstance()来创建持久化类的实例了。通常构造器的访问控制修饰符至少是包可见的</li>
<li>提供一个标识属性: 标识属性通常映射数据库表的主键字段，对于基本类型，建议使用其对应的包装类型</li>
<li>为持久化类的每个成员变量提供setter和getter方法: Hibernate默认采用属性方式来访问持久化类的成员变量</li>
<li>使用非final的类: 在运行时生成代理是Hibernate的一个重要功能，如果非要使用一个有public final方法的类，则必须通过设置lazy&#x3D;”false”来明确地禁用代理</li>
<li>重写equals()和hashCode()方法: 如果需要把持久化类的实例放入Set中，则应该为持久化类重写equals()和hashCode()方法</li>
</ul>
<h4 id="持久化类对象的状态"><a href="#持久化类对象的状态" class="headerlink" title="持久化类对象的状态"></a>持久化类对象的状态</h4><p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/shijiebei2009/img/master/blog/hibernate_life_cycle.gif" title="life-cycle"><img src="https://raw.githubusercontent.com/shijiebei2009/img/master/blog/hibernate_life_cycle.gif" alt="life-cycle" title="life-cycle"></a></p>
<p>在Hibernate中，PO（Persistent Object）有如下三种状态</p>
<ul>
<li>瞬态: 如果PO实例从未与Session关联过，该PO实例处于瞬态状态，瞬态对象不会被持久化到数据库中，也不会被赋予持久化标识</li>
<li>持久化: 如果PO实例与Session关联起来，且该实例对应到数据库记录，则该实例处于持久化状态</li>
<li>脱管: 如果PO实例曾经与Session关联过，但因为Session的关闭等原因，PO实例脱离了Session管理，这种状态为脱管状态，脱管对象的引用仍然有效，对象可继续被修改。如果重新让脱管对象与某个Session关联，这个脱管对象会重新转换为持久化状态，而脱管期间的改动不会丢失，也可被写入数据库</li>
</ul>
<h4 id="更改持久化对象状态的方法"><a href="#更改持久化对象状态的方法" class="headerlink" title="更改持久化对象状态的方法"></a>更改持久化对象状态的方法</h4><p><strong>持久化实体</strong></p>
<ul>
<li>save(): 该方法返回持久化对象的标识属性值（即对应记录的主键值），执行save方法时会立即将持久化对象对应的数据插入数据库</li>
<li>persist(): 该方法保存持久化对象，没有任何返回值，当该方法在一个事务外部被调用时，并不立即转换成insert语句</li>
</ul>
<p><strong>加载持久化实体</strong></p>
<ul>
<li>load(): 该方法具有延迟加载功能，其不会立即访问数据库，当试图加载的记录不存在时，load方法可能返回一个未初始化的代理对象</li>
<li>get(): 该方法总是立即访问数据库，当试图加载的记录不存在时，get方法将直接返回null</li>
</ul>
<p><strong>更新持久化实体</strong><br>程序对持久化实例所做的修改会在Session flush之前被自动保存到数据库，无需程序调用其他方法来将其持久化。也就是说，修改对象最简单的方法就是在Session处于打开状态时load()它，然后直接修改即可。</p>
<p><strong>更新脱管实体</strong><br>当程序使用update()来保存程序对持久化对象所做的修改时，如果不清楚该对象是否曾经持久化过，那么程序可以选择使用updateOrSave()方法，该方法自动判断该对象是否曾经持久化过，如果曾经持久化过，就执行update()操作；否则执行save()操作。merge()方法不会持久化给定的对象，例如<code>session.merge(object)</code>代码后，object依然不是持久化状态，object依然不会被关联到session上，merge()方法会返回object对象的副本——该副本处于持久化状态。</p>
<p><strong>删除持久化实体</strong><br>通过Session的delete()方法来删除持久化实例，一旦删除了该持久化实例，则对应的数据记录也将被删除。</p>
<h3 id="Hibernate进阶"><a href="#Hibernate进阶" class="headerlink" title="Hibernate进阶"></a>Hibernate进阶</h3><h4 id="Hibernate的关联映射"><a href="#Hibernate的关联映射" class="headerlink" title="Hibernate的关联映射"></a>Hibernate的关联映射</h4><p>关联关系大致有两类，一类是单向关系，另一类是双向关系，单向关系可分为</p>
<ul>
<li>单向1-&gt;1</li>
<li>单向1-&gt;N</li>
<li>单向N-&gt;1</li>
<li>单向N-&gt;N</li>
</ul>
<p>双向关联又可分为</p>
<ul>
<li>双向1-&gt;1</li>
<li>双向1-&gt;N</li>
<li>双向N-&gt;N</li>
</ul>
<h4 id="单向N-1关联"><a href="#单向N-1关联" class="headerlink" title="单向N-1关联"></a>单向N-1关联</h4><p>单向的N-1关联只需从N的一端可以访问1的一端，程序应该在N的一端的持久化类中增加一个属性，该属性引用1的一端的关联实体，对于N-1关联（不管是单向，还是双向）都需要在N的一端使用<code>@ManyToOne</code>修饰代表关联实体的属性。</p>
<h4 id="单向1-1关联"><a href="#单向1-1关联" class="headerlink" title="单向1-1关联"></a>单向1-1关联</h4><p>单向的1-1关联关系，需要在持久化类里增加代表关联实体的成员变量，并为该成员变量增加setter和getter方法。从持久化类的代码上看，单向1-1与单向N-1没有丝毫区别。因为N的一端或者1 的一端都是直接访问关联实体，只需增加代表关联实体的属性即可。对于1-1关联（不管是单向关联，还是双向关联），都需要使用<code>@OneToOne</code>修饰代表关联实体的属性。</p>
<h4 id="单向1-N关联"><a href="#单向1-N关联" class="headerlink" title="单向1-N关联"></a>单向1-N关联</h4><p>单向1-N关联的持久化类发生了改变，持久化类里需要使用集合属性。因为1的一端需要访问N的一端，而N的一端将以集合（Set）形式表现。对于单向1-N关联关系，只需要在1的一端增加Set类型的成员变量，该成员变量记录当前实体所有的关联实体。使用<code>@OneToMany</code>注解修饰1的一端对应N的一端的集合。</p>
<h4 id="单向N-N关联"><a href="#单向N-N关联" class="headerlink" title="单向N-N关联"></a>单向N-N关联</h4><p>单向的N-N关联和1-N关联的持久化类代码完全相同，控制关系的一端需要增加一个Set类型的属性，被关联的持久化实例以集合形式存在。N-N关联必须使用连接表，N-N关联与有连接表的1-N关联非常相似，因此都需要使用<code>@JoinTable</code>来映射连接表，区别是N-N关联要去掉<code>@JoinTable</code>注解的<code>inverseJoinColumns</code>属性所指定的<code>@JoinColumn</code>中的<code>unique=true</code>。</p>
<h4 id="双向1-N关联"><a href="#双向1-N关联" class="headerlink" title="双向1-N关联"></a>双向1-N关联</h4><p>对于1-N关联，Hibernate推荐使用双向关联，而且不要让1的一端控制关联关系，而使用N的一端控制关联关系。双向的1-N关联与N-1关联是完全相同的两种情形，两端都需要增加对关联属性的访问，N的一端增加引用到关联实体的属性，1的一端增加集合属性，集合元素为关联实体。<br>无连接表的双向1-N关联，N的一端需要增加<code>@ManyToOne</code>注解来修饰代表关联实体的属性，而1的一端则需要使用<code>@OneToMany</code>注解来修饰代表关联实体的属性。<br>对于有连接表的双向1-N关联而言，1的一端无需任何改变；只要在N的一端使用<code>@JoinTable</code>显式指定连接表即可。</p>
<h4 id="双向N-N关联"><a href="#双向N-N关联" class="headerlink" title="双向N-N关联"></a>双向N-N关联</h4><p>双向N-N关联需要两端都使用Set集合属性，两端都增加对集合属性的访问。双向N-N关联没有太多选择，只能采用连接表来建立两个实体之间的关联关系。<br>双向N-N关联需要在两端分别使用<code>@ManyToMany</code>修饰Set集合属性，并在两端都使用<code>@JoinTable</code>显式映射连接表。在两端映射连接表时，两端指定的连接表的表明应该相同，而且两端使用<code>@JoinTable</code>时指定的外键列的列名也是相互对应的。<br>如果某一段想放弃控制关联关系，则可在这一段的<code>@ManyToMany</code>注解中指定<code>mappedBy</code>属性，这一段就无需、也不能使用<code>@JoinTable</code>映射连接表了。</p>
<h4 id="双向1-1关联"><a href="#双向1-1关联" class="headerlink" title="双向1-1关联"></a>双向1-1关联</h4><p>双向1-1关联需要使用<code>@OneToOne</code>注解进行映射，并让两个持久化类都增加引用关联实体的属性，并为该属性提供setter和getter方法。</p>
<h4 id="基于复合主键的关联关系"><a href="#基于复合主键的关联关系" class="headerlink" title="基于复合主键的关联关系"></a>基于复合主键的关联关系</h4><p>在实际项目中并不推荐使用复合主键，总是建议采用没有物理意义的逻辑主键。复合主键的做法不仅会增加数据库建模的难度，而且会增加关联关系的维护成本。</p>
<h4 id="持久化的传播性"><a href="#持久化的传播性" class="headerlink" title="持久化的传播性"></a>持久化的传播性</h4><p>对于关联实体而言，Hibernate默认不会启用级联操作，当父对象被保存时，它关联的子实体不会被保存；父对象被删除时，它关联的子实体不会被删除。为了启用不同持久化操作的级联关系，Hibernate定义了如下级联风格</p>
<ul>
<li><code>CascadeType.ALL</code>: 指定Hibernate将所所有的持久化操作都级联到关联实体</li>
<li><code>CascadeType.MERGE</code>: 指定Hibernate将merge操作级联到关联实体</li>
<li><code>CascadeType.PERSIST</code>: 指定Hibernate将persist操作级联到关联实体</li>
<li><code>CascadeType.REFRESH</code>: 指定Hibernate将refresh操作级联到关联实体</li>
<li><code>CascadeType.REMOVE</code>: 指定Hibernate将remove操作级联到关联实体<br>如果程序希望某个操作能被级联传播到关联实体，则可以在配置<code>@OneToMany</code>、<code>@OneToOne</code>、<code>@ManyToMany</code>时通过cascade属性来指定。<em>注意级联风格是可组合的。</em></li>
</ul>
<h3 id="事务控制"><a href="#事务控制" class="headerlink" title="事务控制"></a>事务控制</h3><h4 id="Session与事务"><a href="#Session与事务" class="headerlink" title="Session与事务"></a>Session与事务</h4><p>SessionFactory对象的创建代价很高，它是线程安全的对象，被设计成可以被所有线程所共享。通常，SessionFactory会在应用程序启动时创建，一旦创建了SessionFactory就不会轻易关闭，只有当应用退出时才关闭SessionFactory。<br>Session对象是轻量级的，它也是线程不安全的。对于单个业务进程、单个工作单元而言，Session只被使用一次。创建Session时，并不会立即打开与数据库之间的连接，只有需要进行数据库操作时，Session才会获取JDBC连接。因此，打开和关闭Session，并不会对性能造成很大的影响。</p>
<h4 id="一级、二级缓存"><a href="#一级、二级缓存" class="headerlink" title="一级、二级缓存"></a>一级、二级缓存</h4><p>Hibernate包括两个级别的缓存</p>
<ul>
<li>默认总是启用的Session级别的一级缓存</li>
<li>可选的SessionFactory级别的二级缓存</li>
</ul>
<p>其中Session级别的一级缓存不需要开发者关心，默认总是有效的，当应用保存持久化实体、修改持久化实体时，Session并不会立即把这种改变flush到数据库，而是缓存在当前Session的一级缓存中，除非程序显式调用Session的flush()方法，或程序关闭Session时才会把这些改变一次性的flush到底层数据库。</p>
<p>SessionFactory级别的二级缓存是全局性的，应用的所有Session都共享这个二级缓存。不过SessionFactory级别的二级缓存默认是关闭的，必须由程序显式开启。一旦在应用程序中开启了二级缓存，当Session需要抓取数据时，Session将会先查找一级缓存，再查找二级缓存，只有当一级缓存和二级缓存中都没有要抓取的数据时，才会去查找底层数据库。</p>
<h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><p>一级、二级缓存都是对整个实体进行缓存，它不会缓存普通属性，如果想对普通属性进行缓存，则可以考虑使用查询缓存。</p>
<p><em><strong>Notes</strong></em></p>
<blockquote>
<p>需要指出的是，在大部分情况下查询缓存并不能提高应用性能，甚至反而会降低应用性能，因此在实际项目中请慎重使用查询缓存。</p>
</blockquote>
<p>对于查询缓存来说，它缓存的key就是查询所用的HQL或SQL语句。需要指出的是，查询缓存不仅要求所使用的HQL或SQL语句相同，甚至要求所传入的参数也相同，Hibernate才能直接从查询缓存中取得数据。</p>
<p>查询缓存默认是关闭的，为了开启需要在hibernate.cfg.xml中配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.cache.use_query_cache&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>除此之外，在程序中还必须调用Query对象的<code>setCacheable(true)</code>才会对查询结果进行缓存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置查询缓存，在第二次查询时不会重新发出SQL语句进行查询</span></span><br><span class="line">session.createQuery(<span class="string">&quot;select name, age from person&quot;</span>).setCacheable(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<h3 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h3><p>在Hibernate执行持久化的过程中，应用程序通常都无法参与其中。所有的数据持久化操作，对用户都是透明的，用户无法插入自己的动作。<br>通过事件框架，Hibernate允许应用程序能响应特定的内部事件，从而允许实现某些通用的功能，或者对Hibernate功能进行扩展。<br>Hibernate的事件框架由两部分组成</p>
<ul>
<li>拦截器机制: 对于特定动作拦截，回调应用中的特定动作</li>
<li>事件系统: 重写Hibernate的事件监听器</li>
</ul>
<h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><p>拦截器通过Interceptor接口，可以从Session中回调应用程序的特定方法，这种回调机制可让应用程序在持久化对象被保存、更新、删除或加载之前，检查并修改其属性。<br>通过Interceptor接口，可以在数据进入数据库之前，对数据进行最后的检查，如果数据不符合要求，则可以修改数据，从而避免非法数据进入数据库。<br>使用拦截器按如下步骤进行</p>
<ul>
<li>定义实现Interceptor接口的拦截器类</li>
<li>通过Session启用拦截器，或者通过Configuration启用全局拦截器</li>
</ul>
<h4 id="事件系统"><a href="#事件系统" class="headerlink" title="事件系统"></a>事件系统</h4><p>Hibernate的事件系统完全可以替代拦截器，也可以作为拦截器的补充来使用。<br>使用事件系统按如下步骤进行</p>
<ul>
<li>实现自己的事件监听器类</li>
<li>注册自定义事件监听器，代替系统默认的事件监听器</li>
</ul>
<p>实现用户的自定义监听器有如下三种方法</p>
<ol>
<li>实现对应的监听器接口: 实现接口必须实现接口内的所有方法，关键是必须实现Hibernate对应的持久化操作，即数据库访问，这以为这程序员完全取代了Hibernate的底层操作</li>
<li>继承事件适配器:  可以有选择则行地实现需要关注的方法，但依然试图取代Hibernate完成数据库的访问</li>
<li>继承系统默认的事件监听器: 扩展特定方法</li>
</ol>
<p>通常推荐采用第三种方法实现自己的事件监听器。Hibernate默认的事件监听器都被声明成non-final，以便用户继承他们。</p>
<p><strong>参考文献</strong><br>[1] 轻量级JavaEE企业应用实战-Struts2+Spring4+Hibernate整合开发</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.sovdating.com/Basic-knowledge-summary-of-Struts2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DJY">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sovdating Linux">
      <meta itemprop="description" content="Hello dev">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sovdating Linux">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/Basic-knowledge-summary-of-Struts2/" class="post-title-link" itemprop="url">Struts2基础知识汇总</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2015-06-18 15:41:01" itemprop="dateCreated datePublished" datetime="2015-06-18T15:41:01+08:00">2015-06-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-01-24 10:24:42" itemprop="dateModified" datetime="2024-01-24T10:24:42+08:00">2024-01-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming-Notes/" itemprop="url" rel="index"><span itemprop="name">Programming Notes</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/shijiebei2009/img/master/blog/struts2_logo.png" title="logo"><img src="https://raw.githubusercontent.com/shijiebei2009/img/master/blog/struts2_logo.png" alt="logo" title="logo"></a></p>
<h3 id="Struts2简介"><a href="#Struts2简介" class="headerlink" title="Struts2简介"></a>Struts2简介</h3><p>Struts2是由传统的Struts1、WebWork两个经典的MVC框架发展起来，如下图所示，无论从Struts2设计的角度还是在实际项目中的易用性来看，Struts2都是一个非常优秀的MVC框架，当然目前还有另外一个非常优秀的MVC框架——SpringMVC，以后再对它进行介绍。<br><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/shijiebei2009/img/master/blog/webwork_struts2.png" title="Struts2"><img src="https://raw.githubusercontent.com/shijiebei2009/img/master/blog/webwork_struts2.png" alt="Struts2" title="Struts2"></a></p>
<h3 id="实现Action"><a href="#实现Action" class="headerlink" title="实现Action"></a>实现Action</h3><p>Struts2的Action类是一个普通的POJO（通常应该包含一个无参数的execute方法），Struts2直接使用Action来封装HTTP请求参数，因此，Action类里还应该包含与请求参数对应的实例变量，并且为这些实例变量提供对应的setter和getter方法。注意其实实例变量是可以省略的，因为Struts2是通过对应的setter和getter方法来处理请求参数的，而不是通过实例变量名来处理请求参数的。</p>
<h4 id="Action访问Servlet-API"><a href="#Action访问Servlet-API" class="headerlink" title="Action访问Servlet API"></a>Action访问Servlet API</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ActionContext</span> <span class="variable">ctx</span> <span class="operator">=</span> ActionContext.getContext();<span class="comment">//相当于JSP中内置的request</span></span><br><span class="line">ctx.getApplication();<span class="comment">//返回Map对象，该对象模拟了ServletContext实例，相当于JSP中内置的application</span></span><br><span class="line">ctx.getSession();<span class="comment">//返回Map对象，该对象模拟了HttpSession实例，相当于JSP中内置的session</span></span><br></pre></td></tr></table></figure>
<h4 id="Action直接访问Servlet-API"><a href="#Action直接访问Servlet-API" class="headerlink" title="Action直接访问Servlet API"></a>Action直接访问Servlet API</h4><p>Struts2提供了几个接口供我们直接访问ServletAPI</p>
<ul>
<li><code>ServletContextAware</code>: 实现该接口的Action可以直接访问Web应用的ServletContext实例</li>
<li><code>ServletRequestAware</code>: 实现该接口的Action可以直接访问用户请求的HttpServletRequest实例</li>
<li><code>ServletResponseAware</code>: 实现该接口的Action可以直接访问服务器响应的HttpServletResponse实例</li>
</ul>
<h4 id="使用ServletActionContext访问Servlet-API"><a href="#使用ServletActionContext访问Servlet-API" class="headerlink" title="使用ServletActionContext访问Servlet API"></a>使用ServletActionContext访问Servlet API</h4><p>Struts2还提供了一个ServletActionContext工具类，这个类包含如下几个静态方法</p>
<ul>
<li><code>static PageContext getPageContext()</code>: 取得Web应用的PageContext对象</li>
<li><code>static HttpServletRequest getRequest()</code>: 取得Web应用的HttpServletRequest对象</li>
<li><code>static HttpServletResponse getResponse()</code>: 取得Web应用的HttpServletResponse对象</li>
<li><code>static ServletContext getServletContext()</code>: 取得Web应用的ServletContext对象</li>
</ul>
<h3 id="Action包和命名空间"><a href="#Action包和命名空间" class="headerlink" title="Action包和命名空间"></a>Action包和命名空间</h3><p>在struts.xml中配置Action，如果没有指定namespace属性，那么该包使用默认的命名空间，如果namespace&#x3D;”&#x2F;“表示指定根命名空间。默认命名空间里的Action可以处理任何命名空间下的Action请求，但根命名空间下的Action只处理根命名空间下的Action请求，这是根命名空间和默认命名空间的区别。</p>
<h4 id="配置默认Action"><a href="#配置默认Action" class="headerlink" title="配置默认Action"></a>配置默认Action</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;...&quot;</span> <span class="attr">extends</span>=<span class="string">&quot;struts-default&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">default-action-ref</span> <span class="attr">name</span>=<span class="string">&quot;simpleViewAction&quot;</span>/&gt;</span></span><br><span class="line">    //当用户请求找不到对应的Action时，系统默认的Action将处理用户请求</span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">&quot;simpleViewAction&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result...</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>将默认Action配置在默认命名空间里就可以让该Action处理所有用户请求，因为默认命名空间的Action可以处理任何命名空间的请求。</p>
<h3 id="Struts2内建的支持结果类型"><a href="#Struts2内建的支持结果类型" class="headerlink" title="Struts2内建的支持结果类型"></a>Struts2内建的支持结果类型</h3><ul>
<li>chain: Action链式处理的结果类型</li>
<li>dispatcher: 用于指定使用JSP作为视图的结果类型，默认值</li>
<li>freemarker: 用于指定使用FreeMarker模板作为视图的结果类型</li>
<li>httpheader: 用于控制特殊的HTTP行为的结果类型</li>
<li>redirect: 用于直接跳转到其他URL的结果类型</li>
<li>redirectAction: 用于直接跳转到其他Action的结果类型</li>
<li>stream: 用于向浏览器返回一个InputStream</li>
<li>velocity: 用于指定使用Velocity模板作为视图的结果类型</li>
<li>xslt: 用于与XML&#x2F;XSLT整合的结果类型</li>
<li>plainText: 用于显示某个页面的原始代码的结果类型</li>
</ul>
<p><em><strong>Notes</strong></em></p>
<ol>
<li>dispatcher结果类型是将请求forward（转发）到指定的JSP资源；而redirect结果类型，是将请求redirect（重定向）到指定的视图资源，重定向会丢失所有的请求参数、请求属性——当然也丢失了Action的处理结果。</li>
<li>使用redirect类型的结果时，不能重定向到<code>/WEB-INF/</code>路径下任何资源，因为重定向相当于重新发送请求，而Web应用的<code>/WEB-INF/</code>路径下资源是受保护资源。</li>
<li>使用redirectAction结果类型时，系统将重新生成一个新请求，只是该请求的URL是一个Action，因此前一个Action处理结果、请求参数、请求属性都会丢失。</li>
</ol>
<h3 id="Struts2异常处理"><a href="#Struts2异常处理" class="headerlink" title="Struts2异常处理"></a>Struts2异常处理</h3><h4 id="Struts2开启异常映射"><a href="#Struts2开启异常映射" class="headerlink" title="Struts2开启异常映射"></a>Struts2开启异常映射</h4><p>默认的在struts-default.xml中已经开启了异常映射，代码如下</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">interceptors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置异常处理的拦截器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interceptor</span> <span class="attr">name</span>=<span class="string">&quot;exception&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.opensymphony.xwork.interceptor.ExceptionMapping.Interceptor&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interceptor-stakc</span> <span class="attr">name</span>=<span class="string">&quot;defaultStack&quot;</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">&lt;!--加入默认的拦截器栈--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">&quot;exception&quot;</span>/&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">interceptor-stakc</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="Struts2输出异常信息"><a href="#Struts2输出异常信息" class="headerlink" title="Struts2输出异常信息"></a>Struts2输出异常信息</h4><p><code>&lt;s:property value=&quot;exception&quot;/&gt;</code>: 输出异常对象本身<br><code>&lt;s:property value=&quot;exceptionStck&quot;/&gt;</code>: 输出异常堆栈信息<br><code>&lt;s:property value=&quot;exception.message&quot;/&gt;</code>: 输出异常的message消息</p>
<h4 id="Convention插件与“约定”支持"><a href="#Convention插件与“约定”支持" class="headerlink" title="Convention插件与“约定”支持"></a>Convention插件与“约定”支持</h4><p>有Ruby on Rails开发经验的朋友知道Rails有一条重要原则：约定优于配置。Rails开发者只需要按约定开发ActiveRecord&#x2F;ActiveController即可，无需进行配置。Struts2的Convention插件借鉴了Rails的创意。</p>
<h5 id="Action的搜索和映射约定"><a href="#Action的搜索和映射约定" class="headerlink" title="Action的搜索和映射约定"></a>Action的搜索和映射约定</h5><p>使用Convention插件，将Struts2项目下的struts2-convention-plugin-2.3.16.3.jar复制到项目的WEB-INF&#x2F;lib下即可。<br>对于Convention插件而言，它会自动搜索位于action、actions、struts、struts2包下的所有Java类，Convention插件会把如下两种Java类当成Action处理。</p>
<ul>
<li>所有实现了com.opensymphony.xwork2.Action的Java类</li>
<li>所有类名以Action结尾的Java类</li>
</ul>
<p>Struts2的Convention插件还允许设置如下三个常量</p>
<ul>
<li>struts.convention.exclude.packages: 指定不扫描哪些包下的Java类，位于这些包结构下的Java类将不会被自动映射成Action</li>
<li>struts.convention.package.locators: Convention插件使用该常量指定的包作为搜寻Action的根包。例如actions.base.LoginAction类，按约定原本映射到&#x2F;base&#x2F;login；如果将该常量设置为base，则该Action将会映射到&#x2F;login</li>
<li>struts.convention.action.packages: Convention插件以该常量指定包作为根包来搜索Action类，Convention插件除了扫描action、actions、struts、struts2四个包的类之外，还会扫描该常量指定的一个或多个包，Convention会视图从中发现Action类</li>
</ul>
<p>部署Action时，action、actions、struts、struts2包会映射成根（&#x2F;）命名空间，而这些包下的子包则被映射成对应的命名空间。<br>例如：edu.shu.action.base.LoginAction 映射到&#x2F;base&#x2F;命名空间</p>
<p>Action的那么属性（即该Action处理的URL）根据Action的类名映射，需遵循如下两步规则：</p>
<ul>
<li>如果该Action类名包含Action后缀，将该Acting类名的Action后缀去掉，否则不做任何处理</li>
<li>将Action类名的驼峰写法转成中划线写法，所有字母小写</li>
</ul>
<p>例如edu.shu.action.base.UserLoginAction映射的URL是&#x2F;base&#x2F;user-login.action</p>
<h5 id="按约定映射Result"><a href="#按约定映射Result" class="headerlink" title="按约定映射Result"></a>按约定映射Result</h5><p>Convention默认也为作为逻辑视图和物理视图之间的映射提供了约定，默认情况下，Convention总会到Web应用的WEB-INF&#x2F;content路径下定位物理资源，定位资源的约定是actionName+resultcode+suffix。当某个逻辑视图找不到对应的视图资源时，Convention会自动视图使用actionName+sufix作为物理视图资源。</p>
<p>|Action的URL|返回的逻辑视图名|结果类型|对应的物理视图|<br>| ——–   | —–:  | :—-:  |<br>|&#x2F;login|success|Dispatcher|\WEB-INF\content\login-success.jsp<br>|&#x2F;login|success|Dispatcher|\WEB-INF\content\login-success.html<br>|&#x2F;login|success|Dispatcher|\WEB-INF\content\login.jsp<br>|&#x2F;login|success|Dispatcher|\WEB-INF\content\login.html<br>|&#x2F;shu&#x2F;get-book|error|FreeMarker|\WEB-INF\content\shu\get-book-error.ftl<br>|&#x2F;shu&#x2F;get-book|error|FreeMarker|\WEB-INF\content\shu\get-book.ftl<br>|&#x2F;shu&#x2F;get-book|input|Velocity|\WEB-INF\content\shu\get-book-input.vm<br>|&#x2F;shu&#x2F;get|input|Velocity|\WEB-INF\content\shu\get-input.vm</p>
<h5 id="Action链的约定"><a href="#Action链的约定" class="headerlink" title="Action链的约定"></a>Action链的约定</h5><p>如果希望一个Action处理结束后不是进入视图页面，而是进入另一个Action形成的Action链，则通过Convention插件只需遵守如下三个约定</p>
<ul>
<li>第一个Action返回的逻辑视图字符串没有对应的视图资源</li>
<li>第二个Action与第一个Action处于同一个包下</li>
<li>第二个Action映射的URL为: firstactionName+resultcode</li>
</ul>
<h5 id="自动重加载映射"><a href="#自动重加载映射" class="headerlink" title="自动重加载映射"></a>自动重加载映射</h5><p>在struts.xml中配置如下两个常量即可使Convention插件重加载映射</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">&quot;struts.devMode&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">&quot;struts.convention.classes.reload&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Struts2标签库"><a href="#Struts2标签库" class="headerlink" title="Struts2标签库"></a>Struts2标签库</h3><h4 id="Struts2标签库概述"><a href="#Struts2标签库概述" class="headerlink" title="Struts2标签库概述"></a>Struts2标签库概述</h4><p>从最大的范围来分，Struts2可以将所有标签分成如下三类</p>
<ol>
<li>UI标签: 主要用于生成HTML元素的标签<br>1.1. 表单标签: 主要用于生成HTML页面的form元素，以及普通表单元素的标签<br>1.2. 非表单元素: 主要用于生成页面的树、Tab页等标签</li>
<li>非UI标签: 主要用于数据访问、逻辑控制等的标签<br>2.1 流程控制标签: 主要包含用于实现分支、循环等流程控制的标签<br>2.2 数据访问标签: 主要包含用于输出ValueStack中的值、完成国际化等功能的标签</li>
<li>Ajax标签: 用于Ajax支持的标签</li>
</ol>
<h4 id="OGNL表达式语言"><a href="#OGNL表达式语言" class="headerlink" title="OGNL表达式语言"></a>OGNL表达式语言</h4><p>OGNL的顶级对象是Stack Context，Stack Context对象就是一个Map类型的实例，其根对象就是Value Stack。OGNL的Stack Context里除了包括ValueStack这个根之外，还包括parameters、request、session、application、attr等命名对象，但这些命名对象都不是根。Stack Context“根”对象和普通命名对象的区别在于</p>
<ul>
<li>访问Stack Context里的命名对象需要在对象名之前添加#前缀</li>
<li>访问OGNL的Stack Context里“根”对象的属性时，可以省略对象名</li>
</ul>
<h3 id="Struts2拦截器"><a href="#Struts2拦截器" class="headerlink" title="Struts2拦截器"></a>Struts2拦截器</h3><h4 id="配置默认拦截器"><a href="#配置默认拦截器" class="headerlink" title="配置默认拦截器"></a>配置默认拦截器</h4><p>当配置一个包时，可以为其指定默认拦截器。一旦为某个包指定了默认的拦截器，如果该包中的Action没有显式指定拦截器，则默认的拦截器将会起作用。如果一旦为该包中的Action显式应用了某个拦截器，则默认的拦截器不会起作用，如果该Action还需要使用默认拦截器，则必须手动配置该拦截器的引用。</p>
<h4 id="拦截器的执行顺序"><a href="#拦截器的执行顺序" class="headerlink" title="拦截器的执行顺序"></a>拦截器的执行顺序</h4><p>在Action的控制方法执行之前，位于拦截器链前面的拦截器将先发生作用；在Action的控制方法执行之后，位于拦截器链前面的拦截器将后发生作用。</p>
<p><strong>参考文献</strong><br>[1] 轻量级JavaEE企业应用实战-Struts2+Spring4+Hibernate整合开发</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.sovdating.com/download-app-in-weixin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DJY">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sovdating Linux">
      <meta itemprop="description" content="Hello dev">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sovdating Linux">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/download-app-in-weixin/" class="post-title-link" itemprop="url">微信WebView下载应用解决方案</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2015-06-17 21:44:23" itemprop="dateCreated datePublished" datetime="2015-06-17T21:44:23+08:00">2015-06-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-01-24 10:14:31" itemprop="dateModified" datetime="2024-01-24T10:14:31+08:00">2024-01-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/technology/" itemprop="url" rel="index"><span itemprop="name">technology</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>众所周知，微信会屏蔽掉直接的app下载链接，那么有没有办法可以让用户能够在微信里面点一个链接或者识别二维码下载应用呢？答案是肯定的。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/download-app-in-weixin/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.sovdating.com/Basic-knowledge-summary-of-JSP-Servlet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DJY">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sovdating Linux">
      <meta itemprop="description" content="Hello dev">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sovdating Linux">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/Basic-knowledge-summary-of-JSP-Servlet/" class="post-title-link" itemprop="url">JSP/Servlet基础知识汇总</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2015-06-17 18:25:37" itemprop="dateCreated datePublished" datetime="2015-06-17T18:25:37+08:00">2015-06-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-01-24 10:24:42" itemprop="dateModified" datetime="2024-01-24T10:24:42+08:00">2024-01-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming-Notes/" itemprop="url" rel="index"><span itemprop="name">Programming Notes</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="JSP与Servlet"><a href="#JSP与Servlet" class="headerlink" title="JSP与Servlet"></a>JSP与Servlet</h3><p>所有的JSP页面最终都会被编译成Servlet执行，而在Servlet类中主要有三个方法，分别是</p>
<ul>
<li>init(): 初始化JSP&#x2F;Servlet的方法</li>
<li>destroy(): 销毁JSP&#x2F;Servlet的方法</li>
<li>service(): 对用户请求生成响应的方法</li>
</ul>
<p>JSP页面必须放到应用服务器中运行，当第一次访问JSP页面时，该JSP页面会被编译成Servlet，如果JSP没有改动的话，以后访问的都是第一次编译成功的Servlet。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/Basic-knowledge-summary-of-JSP-Servlet/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/48/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/48/">48</a><span class="page-number current">49</span><a class="page-number" href="/page/50/">50</a><span class="space">&hellip;</span><a class="page-number" href="/page/55/">55</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/50/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">DJY</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
